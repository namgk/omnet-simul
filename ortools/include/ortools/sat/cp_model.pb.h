// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/cp_model.proto

#ifndef PROTOBUF_ortools_2fsat_2fcp_5fmodel_2eproto__INCLUDED
#define PROTOBUF_ortools_2fsat_2fcp_5fmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace operations_research {
namespace sat {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

class AllDifferentConstraintProto;
class AutomataConstraintProto;
class BoolArgumentProto;
class CircuitConstraintProto;
class ConstraintProto;
class CpModelProto;
class CpObjectiveProto;
class CpSolverResponse;
class CumulativeConstraintProto;
class DecisionStrategyProto;
class DecisionStrategyProto_AffineTransformation;
class ElementConstraintProto;
class IntegerArgumentProto;
class IntegerVariableProto;
class IntervalConstraintProto;
class InverseConstraintProto;
class LinearConstraintProto;
class NoOverlap2DConstraintProto;
class NoOverlapConstraintProto;
class TableConstraintProto;

enum DecisionStrategyProto_VariableSelectionStrategy {
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_FIRST = 0,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_LOWEST_MIN = 1,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_HIGHEST_MAX = 2,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MIN_DOMAIN_SIZE = 3,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MAX_DOMAIN_SIZE = 4,
  DecisionStrategyProto_VariableSelectionStrategy_DecisionStrategyProto_VariableSelectionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DecisionStrategyProto_VariableSelectionStrategy_DecisionStrategyProto_VariableSelectionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DecisionStrategyProto_VariableSelectionStrategy_IsValid(int value);
const DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MIN = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_FIRST;
const DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MAX = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MAX_DOMAIN_SIZE;
const int DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_ARRAYSIZE = DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecisionStrategyProto_VariableSelectionStrategy_descriptor();
inline const ::std::string& DecisionStrategyProto_VariableSelectionStrategy_Name(DecisionStrategyProto_VariableSelectionStrategy value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecisionStrategyProto_VariableSelectionStrategy_descriptor(), value);
}
inline bool DecisionStrategyProto_VariableSelectionStrategy_Parse(
    const ::std::string& name, DecisionStrategyProto_VariableSelectionStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecisionStrategyProto_VariableSelectionStrategy>(
    DecisionStrategyProto_VariableSelectionStrategy_descriptor(), name, value);
}
enum DecisionStrategyProto_DomainReductionStrategy {
  DecisionStrategyProto_DomainReductionStrategy_SELECT_MIN_VALUE = 0,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_MAX_VALUE = 1,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_LOWER_HALF = 2,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_UPPER_HALF = 3,
  DecisionStrategyProto_DomainReductionStrategy_DecisionStrategyProto_DomainReductionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DecisionStrategyProto_DomainReductionStrategy_DecisionStrategyProto_DomainReductionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DecisionStrategyProto_DomainReductionStrategy_IsValid(int value);
const DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MIN = DecisionStrategyProto_DomainReductionStrategy_SELECT_MIN_VALUE;
const DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MAX = DecisionStrategyProto_DomainReductionStrategy_SELECT_UPPER_HALF;
const int DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_ARRAYSIZE = DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecisionStrategyProto_DomainReductionStrategy_descriptor();
inline const ::std::string& DecisionStrategyProto_DomainReductionStrategy_Name(DecisionStrategyProto_DomainReductionStrategy value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecisionStrategyProto_DomainReductionStrategy_descriptor(), value);
}
inline bool DecisionStrategyProto_DomainReductionStrategy_Parse(
    const ::std::string& name, DecisionStrategyProto_DomainReductionStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecisionStrategyProto_DomainReductionStrategy>(
    DecisionStrategyProto_DomainReductionStrategy_descriptor(), name, value);
}
enum CpSolverStatus {
  UNKNOWN = 0,
  MODEL_INVALID = 1,
  MODEL_SAT = 2,
  MODEL_UNSAT = 3,
  OPTIMAL = 4,
  CpSolverStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CpSolverStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CpSolverStatus_IsValid(int value);
const CpSolverStatus CpSolverStatus_MIN = UNKNOWN;
const CpSolverStatus CpSolverStatus_MAX = OPTIMAL;
const int CpSolverStatus_ARRAYSIZE = CpSolverStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CpSolverStatus_descriptor();
inline const ::std::string& CpSolverStatus_Name(CpSolverStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CpSolverStatus_descriptor(), value);
}
inline bool CpSolverStatus_Parse(
    const ::std::string& name, CpSolverStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CpSolverStatus>(
    CpSolverStatus_descriptor(), name, value);
}
// ===================================================================

class IntegerVariableProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.IntegerVariableProto) */ {
 public:
  IntegerVariableProto();
  virtual ~IntegerVariableProto();

  IntegerVariableProto(const IntegerVariableProto& from);

  inline IntegerVariableProto& operator=(const IntegerVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegerVariableProto& default_instance();

  void Swap(IntegerVariableProto* other);

  // implements Message ----------------------------------------------

  inline IntegerVariableProto* New() const { return New(NULL); }

  IntegerVariableProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegerVariableProto& from);
  void MergeFrom(const IntegerVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntegerVariableProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated int64 domain = 2;
  int domain_size() const;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  ::google::protobuf::int64 domain(int index) const;
  void set_domain(int index, ::google::protobuf::int64 value);
  void add_domain(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      domain() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_domain();

  // @@protoc_insertion_point(class_scope:operations_research.sat.IntegerVariableProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > domain_;
  mutable int _domain_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegerVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class BoolArgumentProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.BoolArgumentProto) */ {
 public:
  BoolArgumentProto();
  virtual ~BoolArgumentProto();

  BoolArgumentProto(const BoolArgumentProto& from);

  inline BoolArgumentProto& operator=(const BoolArgumentProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolArgumentProto& default_instance();

  void Swap(BoolArgumentProto* other);

  // implements Message ----------------------------------------------

  inline BoolArgumentProto* New() const { return New(NULL); }

  BoolArgumentProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolArgumentProto& from);
  void MergeFrom(const BoolArgumentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoolArgumentProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  ::google::protobuf::int32 literals(int index) const;
  void set_literals(int index, ::google::protobuf::int32 value);
  void add_literals(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      literals() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_literals();

  // @@protoc_insertion_point(class_scope:operations_research.sat.BoolArgumentProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > literals_;
  mutable int _literals_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static BoolArgumentProto* default_instance_;
};
// -------------------------------------------------------------------

class IntegerArgumentProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.IntegerArgumentProto) */ {
 public:
  IntegerArgumentProto();
  virtual ~IntegerArgumentProto();

  IntegerArgumentProto(const IntegerArgumentProto& from);

  inline IntegerArgumentProto& operator=(const IntegerArgumentProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegerArgumentProto& default_instance();

  void Swap(IntegerArgumentProto* other);

  // implements Message ----------------------------------------------

  inline IntegerArgumentProto* New() const { return New(NULL); }

  IntegerArgumentProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegerArgumentProto& from);
  void MergeFrom(const IntegerArgumentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntegerArgumentProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // repeated int32 vars = 2;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 2;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // @@protoc_insertion_point(class_scope:operations_research.sat.IntegerArgumentProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  ::google::protobuf::int32 target_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegerArgumentProto* default_instance_;
};
// -------------------------------------------------------------------

class AllDifferentConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.AllDifferentConstraintProto) */ {
 public:
  AllDifferentConstraintProto();
  virtual ~AllDifferentConstraintProto();

  AllDifferentConstraintProto(const AllDifferentConstraintProto& from);

  inline AllDifferentConstraintProto& operator=(const AllDifferentConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllDifferentConstraintProto& default_instance();

  void Swap(AllDifferentConstraintProto* other);

  // implements Message ----------------------------------------------

  inline AllDifferentConstraintProto* New() const { return New(NULL); }

  AllDifferentConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllDifferentConstraintProto& from);
  void MergeFrom(const AllDifferentConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllDifferentConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // @@protoc_insertion_point(class_scope:operations_research.sat.AllDifferentConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static AllDifferentConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class LinearConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.LinearConstraintProto) */ {
 public:
  LinearConstraintProto();
  virtual ~LinearConstraintProto();

  LinearConstraintProto(const LinearConstraintProto& from);

  inline LinearConstraintProto& operator=(const LinearConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearConstraintProto& default_instance();

  void Swap(LinearConstraintProto* other);

  // implements Message ----------------------------------------------

  inline LinearConstraintProto* New() const { return New(NULL); }

  LinearConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearConstraintProto& from);
  void MergeFrom(const LinearConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // repeated int64 coeffs = 2;
  int coeffs_size() const;
  void clear_coeffs();
  static const int kCoeffsFieldNumber = 2;
  ::google::protobuf::int64 coeffs(int index) const;
  void set_coeffs(int index, ::google::protobuf::int64 value);
  void add_coeffs(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      coeffs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_coeffs();

  // repeated int64 domain = 3;
  int domain_size() const;
  void clear_domain();
  static const int kDomainFieldNumber = 3;
  ::google::protobuf::int64 domain(int index) const;
  void set_domain(int index, ::google::protobuf::int64 value);
  void add_domain(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      domain() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_domain();

  // @@protoc_insertion_point(class_scope:operations_research.sat.LinearConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > coeffs_;
  mutable int _coeffs_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > domain_;
  mutable int _domain_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static LinearConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class ElementConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.ElementConstraintProto) */ {
 public:
  ElementConstraintProto();
  virtual ~ElementConstraintProto();

  ElementConstraintProto(const ElementConstraintProto& from);

  inline ElementConstraintProto& operator=(const ElementConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementConstraintProto& default_instance();

  void Swap(ElementConstraintProto* other);

  // implements Message ----------------------------------------------

  inline ElementConstraintProto* New() const { return New(NULL); }

  ElementConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElementConstraintProto& from);
  void MergeFrom(const ElementConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional int32 target = 2;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // repeated int32 vars = 3;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 3;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // @@protoc_insertion_point(class_scope:operations_research.sat.ElementConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 target_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static ElementConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class IntervalConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.IntervalConstraintProto) */ {
 public:
  IntervalConstraintProto();
  virtual ~IntervalConstraintProto();

  IntervalConstraintProto(const IntervalConstraintProto& from);

  inline IntervalConstraintProto& operator=(const IntervalConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntervalConstraintProto& default_instance();

  void Swap(IntervalConstraintProto* other);

  // implements Message ----------------------------------------------

  inline IntervalConstraintProto* New() const { return New(NULL); }

  IntervalConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntervalConstraintProto& from);
  void MergeFrom(const IntervalConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntervalConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // optional int32 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:operations_research.sat.IntervalConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntervalConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class NoOverlapConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.NoOverlapConstraintProto) */ {
 public:
  NoOverlapConstraintProto();
  virtual ~NoOverlapConstraintProto();

  NoOverlapConstraintProto(const NoOverlapConstraintProto& from);

  inline NoOverlapConstraintProto& operator=(const NoOverlapConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoOverlapConstraintProto& default_instance();

  void Swap(NoOverlapConstraintProto* other);

  // implements Message ----------------------------------------------

  inline NoOverlapConstraintProto* New() const { return New(NULL); }

  NoOverlapConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoOverlapConstraintProto& from);
  void MergeFrom(const NoOverlapConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NoOverlapConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 intervals = 1;
  int intervals_size() const;
  void clear_intervals();
  static const int kIntervalsFieldNumber = 1;
  ::google::protobuf::int32 intervals(int index) const;
  void set_intervals(int index, ::google::protobuf::int32 value);
  void add_intervals(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intervals() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intervals();

  // @@protoc_insertion_point(class_scope:operations_research.sat.NoOverlapConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intervals_;
  mutable int _intervals_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static NoOverlapConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class NoOverlap2DConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.NoOverlap2DConstraintProto) */ {
 public:
  NoOverlap2DConstraintProto();
  virtual ~NoOverlap2DConstraintProto();

  NoOverlap2DConstraintProto(const NoOverlap2DConstraintProto& from);

  inline NoOverlap2DConstraintProto& operator=(const NoOverlap2DConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoOverlap2DConstraintProto& default_instance();

  void Swap(NoOverlap2DConstraintProto* other);

  // implements Message ----------------------------------------------

  inline NoOverlap2DConstraintProto* New() const { return New(NULL); }

  NoOverlap2DConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoOverlap2DConstraintProto& from);
  void MergeFrom(const NoOverlap2DConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NoOverlap2DConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 x_intervals = 1;
  int x_intervals_size() const;
  void clear_x_intervals();
  static const int kXIntervalsFieldNumber = 1;
  ::google::protobuf::int32 x_intervals(int index) const;
  void set_x_intervals(int index, ::google::protobuf::int32 value);
  void add_x_intervals(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      x_intervals() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_x_intervals();

  // repeated int32 y_intervals = 2;
  int y_intervals_size() const;
  void clear_y_intervals();
  static const int kYIntervalsFieldNumber = 2;
  ::google::protobuf::int32 y_intervals(int index) const;
  void set_y_intervals(int index, ::google::protobuf::int32 value);
  void add_y_intervals(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      y_intervals() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_y_intervals();

  // @@protoc_insertion_point(class_scope:operations_research.sat.NoOverlap2DConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > x_intervals_;
  mutable int _x_intervals_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > y_intervals_;
  mutable int _y_intervals_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static NoOverlap2DConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class CumulativeConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.CumulativeConstraintProto) */ {
 public:
  CumulativeConstraintProto();
  virtual ~CumulativeConstraintProto();

  CumulativeConstraintProto(const CumulativeConstraintProto& from);

  inline CumulativeConstraintProto& operator=(const CumulativeConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CumulativeConstraintProto& default_instance();

  void Swap(CumulativeConstraintProto* other);

  // implements Message ----------------------------------------------

  inline CumulativeConstraintProto* New() const { return New(NULL); }

  CumulativeConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CumulativeConstraintProto& from);
  void MergeFrom(const CumulativeConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CumulativeConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 capacity = 1;
  void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  ::google::protobuf::int32 capacity() const;
  void set_capacity(::google::protobuf::int32 value);

  // repeated int32 intervals = 2;
  int intervals_size() const;
  void clear_intervals();
  static const int kIntervalsFieldNumber = 2;
  ::google::protobuf::int32 intervals(int index) const;
  void set_intervals(int index, ::google::protobuf::int32 value);
  void add_intervals(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intervals() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intervals();

  // repeated int32 demands = 3;
  int demands_size() const;
  void clear_demands();
  static const int kDemandsFieldNumber = 3;
  ::google::protobuf::int32 demands(int index) const;
  void set_demands(int index, ::google::protobuf::int32 value);
  void add_demands(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      demands() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_demands();

  // @@protoc_insertion_point(class_scope:operations_research.sat.CumulativeConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intervals_;
  mutable int _intervals_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > demands_;
  mutable int _demands_cached_byte_size_;
  ::google::protobuf::int32 capacity_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static CumulativeConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class CircuitConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.CircuitConstraintProto) */ {
 public:
  CircuitConstraintProto();
  virtual ~CircuitConstraintProto();

  CircuitConstraintProto(const CircuitConstraintProto& from);

  inline CircuitConstraintProto& operator=(const CircuitConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircuitConstraintProto& default_instance();

  void Swap(CircuitConstraintProto* other);

  // implements Message ----------------------------------------------

  inline CircuitConstraintProto* New() const { return New(NULL); }

  CircuitConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CircuitConstraintProto& from);
  void MergeFrom(const CircuitConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CircuitConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 nexts = 2;
  int nexts_size() const;
  void clear_nexts();
  static const int kNextsFieldNumber = 2;
  ::google::protobuf::int32 nexts(int index) const;
  void set_nexts(int index, ::google::protobuf::int32 value);
  void add_nexts(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      nexts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_nexts();

  // @@protoc_insertion_point(class_scope:operations_research.sat.CircuitConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > nexts_;
  mutable int _nexts_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static CircuitConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class TableConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.TableConstraintProto) */ {
 public:
  TableConstraintProto();
  virtual ~TableConstraintProto();

  TableConstraintProto(const TableConstraintProto& from);

  inline TableConstraintProto& operator=(const TableConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableConstraintProto& default_instance();

  void Swap(TableConstraintProto* other);

  // implements Message ----------------------------------------------

  inline TableConstraintProto* New() const { return New(NULL); }

  TableConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableConstraintProto& from);
  void MergeFrom(const TableConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TableConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // repeated int64 values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // optional bool negated = 3;
  void clear_negated();
  static const int kNegatedFieldNumber = 3;
  bool negated() const;
  void set_negated(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.sat.TableConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  bool negated_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static TableConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class InverseConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.InverseConstraintProto) */ {
 public:
  InverseConstraintProto();
  virtual ~InverseConstraintProto();

  InverseConstraintProto(const InverseConstraintProto& from);

  inline InverseConstraintProto& operator=(const InverseConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InverseConstraintProto& default_instance();

  void Swap(InverseConstraintProto* other);

  // implements Message ----------------------------------------------

  inline InverseConstraintProto* New() const { return New(NULL); }

  InverseConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InverseConstraintProto& from);
  void MergeFrom(const InverseConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InverseConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 f_direct = 1;
  int f_direct_size() const;
  void clear_f_direct();
  static const int kFDirectFieldNumber = 1;
  ::google::protobuf::int32 f_direct(int index) const;
  void set_f_direct(int index, ::google::protobuf::int32 value);
  void add_f_direct(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      f_direct() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_f_direct();

  // repeated int32 f_inverse = 2;
  int f_inverse_size() const;
  void clear_f_inverse();
  static const int kFInverseFieldNumber = 2;
  ::google::protobuf::int32 f_inverse(int index) const;
  void set_f_inverse(int index, ::google::protobuf::int32 value);
  void add_f_inverse(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      f_inverse() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_f_inverse();

  // @@protoc_insertion_point(class_scope:operations_research.sat.InverseConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > f_direct_;
  mutable int _f_direct_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > f_inverse_;
  mutable int _f_inverse_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static InverseConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class AutomataConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.AutomataConstraintProto) */ {
 public:
  AutomataConstraintProto();
  virtual ~AutomataConstraintProto();

  AutomataConstraintProto(const AutomataConstraintProto& from);

  inline AutomataConstraintProto& operator=(const AutomataConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutomataConstraintProto& default_instance();

  void Swap(AutomataConstraintProto* other);

  // implements Message ----------------------------------------------

  inline AutomataConstraintProto* New() const { return New(NULL); }

  AutomataConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutomataConstraintProto& from);
  void MergeFrom(const AutomataConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutomataConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 starting_state = 2;
  void clear_starting_state();
  static const int kStartingStateFieldNumber = 2;
  ::google::protobuf::int64 starting_state() const;
  void set_starting_state(::google::protobuf::int64 value);

  // repeated int64 final_states = 3;
  int final_states_size() const;
  void clear_final_states();
  static const int kFinalStatesFieldNumber = 3;
  ::google::protobuf::int64 final_states(int index) const;
  void set_final_states(int index, ::google::protobuf::int64 value);
  void add_final_states(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      final_states() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_final_states();

  // repeated int64 transition_tail = 4;
  int transition_tail_size() const;
  void clear_transition_tail();
  static const int kTransitionTailFieldNumber = 4;
  ::google::protobuf::int64 transition_tail(int index) const;
  void set_transition_tail(int index, ::google::protobuf::int64 value);
  void add_transition_tail(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      transition_tail() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_transition_tail();

  // repeated int64 transition_head = 5;
  int transition_head_size() const;
  void clear_transition_head();
  static const int kTransitionHeadFieldNumber = 5;
  ::google::protobuf::int64 transition_head(int index) const;
  void set_transition_head(int index, ::google::protobuf::int64 value);
  void add_transition_head(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      transition_head() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_transition_head();

  // repeated int64 transition_label = 6;
  int transition_label_size() const;
  void clear_transition_label();
  static const int kTransitionLabelFieldNumber = 6;
  ::google::protobuf::int64 transition_label(int index) const;
  void set_transition_label(int index, ::google::protobuf::int64 value);
  void add_transition_label(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      transition_label() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_transition_label();

  // repeated int32 vars = 7;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 7;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // @@protoc_insertion_point(class_scope:operations_research.sat.AutomataConstraintProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 starting_state_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > final_states_;
  mutable int _final_states_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > transition_tail_;
  mutable int _transition_tail_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > transition_head_;
  mutable int _transition_head_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > transition_label_;
  mutable int _transition_label_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static AutomataConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class ConstraintProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.ConstraintProto) */ {
 public:
  ConstraintProto();
  virtual ~ConstraintProto();

  ConstraintProto(const ConstraintProto& from);

  inline ConstraintProto& operator=(const ConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstraintProto& default_instance();

  enum ConstraintCase {
    kBoolOr = 3,
    kBoolAnd = 4,
    kBoolXor = 5,
    kIntDiv = 7,
    kIntMod = 8,
    kIntMax = 9,
    kIntMin = 10,
    kIntProd = 11,
    kLinear = 12,
    kAllDiff = 13,
    kElement = 14,
    kCircuit = 15,
    kTable = 16,
    kAutomata = 17,
    kInverse = 18,
    kInterval = 19,
    kNoOverlap = 20,
    kNoOverlap2D = 21,
    kCumulative = 22,
    CONSTRAINT_NOT_SET = 0,
  };

  void Swap(ConstraintProto* other);

  // implements Message ----------------------------------------------

  inline ConstraintProto* New() const { return New(NULL); }

  ConstraintProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstraintProto& from);
  void MergeFrom(const ConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConstraintProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated int32 enforcement_literal = 2;
  int enforcement_literal_size() const;
  void clear_enforcement_literal();
  static const int kEnforcementLiteralFieldNumber = 2;
  ::google::protobuf::int32 enforcement_literal(int index) const;
  void set_enforcement_literal(int index, ::google::protobuf::int32 value);
  void add_enforcement_literal(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enforcement_literal() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enforcement_literal();

  // optional .operations_research.sat.BoolArgumentProto bool_or = 3;
  bool has_bool_or() const;
  void clear_bool_or();
  static const int kBoolOrFieldNumber = 3;
  const ::operations_research::sat::BoolArgumentProto& bool_or() const;
  ::operations_research::sat::BoolArgumentProto* mutable_bool_or();
  ::operations_research::sat::BoolArgumentProto* release_bool_or();
  void set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* bool_or);

  // optional .operations_research.sat.BoolArgumentProto bool_and = 4;
  bool has_bool_and() const;
  void clear_bool_and();
  static const int kBoolAndFieldNumber = 4;
  const ::operations_research::sat::BoolArgumentProto& bool_and() const;
  ::operations_research::sat::BoolArgumentProto* mutable_bool_and();
  ::operations_research::sat::BoolArgumentProto* release_bool_and();
  void set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* bool_and);

  // optional .operations_research.sat.BoolArgumentProto bool_xor = 5;
  bool has_bool_xor() const;
  void clear_bool_xor();
  static const int kBoolXorFieldNumber = 5;
  const ::operations_research::sat::BoolArgumentProto& bool_xor() const;
  ::operations_research::sat::BoolArgumentProto* mutable_bool_xor();
  ::operations_research::sat::BoolArgumentProto* release_bool_xor();
  void set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* bool_xor);

  // optional .operations_research.sat.IntegerArgumentProto int_div = 7;
  bool has_int_div() const;
  void clear_int_div();
  static const int kIntDivFieldNumber = 7;
  const ::operations_research::sat::IntegerArgumentProto& int_div() const;
  ::operations_research::sat::IntegerArgumentProto* mutable_int_div();
  ::operations_research::sat::IntegerArgumentProto* release_int_div();
  void set_allocated_int_div(::operations_research::sat::IntegerArgumentProto* int_div);

  // optional .operations_research.sat.IntegerArgumentProto int_mod = 8;
  bool has_int_mod() const;
  void clear_int_mod();
  static const int kIntModFieldNumber = 8;
  const ::operations_research::sat::IntegerArgumentProto& int_mod() const;
  ::operations_research::sat::IntegerArgumentProto* mutable_int_mod();
  ::operations_research::sat::IntegerArgumentProto* release_int_mod();
  void set_allocated_int_mod(::operations_research::sat::IntegerArgumentProto* int_mod);

  // optional .operations_research.sat.IntegerArgumentProto int_max = 9;
  bool has_int_max() const;
  void clear_int_max();
  static const int kIntMaxFieldNumber = 9;
  const ::operations_research::sat::IntegerArgumentProto& int_max() const;
  ::operations_research::sat::IntegerArgumentProto* mutable_int_max();
  ::operations_research::sat::IntegerArgumentProto* release_int_max();
  void set_allocated_int_max(::operations_research::sat::IntegerArgumentProto* int_max);

  // optional .operations_research.sat.IntegerArgumentProto int_min = 10;
  bool has_int_min() const;
  void clear_int_min();
  static const int kIntMinFieldNumber = 10;
  const ::operations_research::sat::IntegerArgumentProto& int_min() const;
  ::operations_research::sat::IntegerArgumentProto* mutable_int_min();
  ::operations_research::sat::IntegerArgumentProto* release_int_min();
  void set_allocated_int_min(::operations_research::sat::IntegerArgumentProto* int_min);

  // optional .operations_research.sat.IntegerArgumentProto int_prod = 11;
  bool has_int_prod() const;
  void clear_int_prod();
  static const int kIntProdFieldNumber = 11;
  const ::operations_research::sat::IntegerArgumentProto& int_prod() const;
  ::operations_research::sat::IntegerArgumentProto* mutable_int_prod();
  ::operations_research::sat::IntegerArgumentProto* release_int_prod();
  void set_allocated_int_prod(::operations_research::sat::IntegerArgumentProto* int_prod);

  // optional .operations_research.sat.LinearConstraintProto linear = 12;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 12;
  const ::operations_research::sat::LinearConstraintProto& linear() const;
  ::operations_research::sat::LinearConstraintProto* mutable_linear();
  ::operations_research::sat::LinearConstraintProto* release_linear();
  void set_allocated_linear(::operations_research::sat::LinearConstraintProto* linear);

  // optional .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
  bool has_all_diff() const;
  void clear_all_diff();
  static const int kAllDiffFieldNumber = 13;
  const ::operations_research::sat::AllDifferentConstraintProto& all_diff() const;
  ::operations_research::sat::AllDifferentConstraintProto* mutable_all_diff();
  ::operations_research::sat::AllDifferentConstraintProto* release_all_diff();
  void set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* all_diff);

  // optional .operations_research.sat.ElementConstraintProto element = 14;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 14;
  const ::operations_research::sat::ElementConstraintProto& element() const;
  ::operations_research::sat::ElementConstraintProto* mutable_element();
  ::operations_research::sat::ElementConstraintProto* release_element();
  void set_allocated_element(::operations_research::sat::ElementConstraintProto* element);

  // optional .operations_research.sat.CircuitConstraintProto circuit = 15;
  bool has_circuit() const;
  void clear_circuit();
  static const int kCircuitFieldNumber = 15;
  const ::operations_research::sat::CircuitConstraintProto& circuit() const;
  ::operations_research::sat::CircuitConstraintProto* mutable_circuit();
  ::operations_research::sat::CircuitConstraintProto* release_circuit();
  void set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* circuit);

  // optional .operations_research.sat.TableConstraintProto table = 16;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 16;
  const ::operations_research::sat::TableConstraintProto& table() const;
  ::operations_research::sat::TableConstraintProto* mutable_table();
  ::operations_research::sat::TableConstraintProto* release_table();
  void set_allocated_table(::operations_research::sat::TableConstraintProto* table);

  // optional .operations_research.sat.AutomataConstraintProto automata = 17;
  bool has_automata() const;
  void clear_automata();
  static const int kAutomataFieldNumber = 17;
  const ::operations_research::sat::AutomataConstraintProto& automata() const;
  ::operations_research::sat::AutomataConstraintProto* mutable_automata();
  ::operations_research::sat::AutomataConstraintProto* release_automata();
  void set_allocated_automata(::operations_research::sat::AutomataConstraintProto* automata);

  // optional .operations_research.sat.InverseConstraintProto inverse = 18;
  bool has_inverse() const;
  void clear_inverse();
  static const int kInverseFieldNumber = 18;
  const ::operations_research::sat::InverseConstraintProto& inverse() const;
  ::operations_research::sat::InverseConstraintProto* mutable_inverse();
  ::operations_research::sat::InverseConstraintProto* release_inverse();
  void set_allocated_inverse(::operations_research::sat::InverseConstraintProto* inverse);

  // optional .operations_research.sat.IntervalConstraintProto interval = 19;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 19;
  const ::operations_research::sat::IntervalConstraintProto& interval() const;
  ::operations_research::sat::IntervalConstraintProto* mutable_interval();
  ::operations_research::sat::IntervalConstraintProto* release_interval();
  void set_allocated_interval(::operations_research::sat::IntervalConstraintProto* interval);

  // optional .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
  bool has_no_overlap() const;
  void clear_no_overlap();
  static const int kNoOverlapFieldNumber = 20;
  const ::operations_research::sat::NoOverlapConstraintProto& no_overlap() const;
  ::operations_research::sat::NoOverlapConstraintProto* mutable_no_overlap();
  ::operations_research::sat::NoOverlapConstraintProto* release_no_overlap();
  void set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* no_overlap);

  // optional .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
  bool has_no_overlap_2d() const;
  void clear_no_overlap_2d();
  static const int kNoOverlap2DFieldNumber = 21;
  const ::operations_research::sat::NoOverlap2DConstraintProto& no_overlap_2d() const;
  ::operations_research::sat::NoOverlap2DConstraintProto* mutable_no_overlap_2d();
  ::operations_research::sat::NoOverlap2DConstraintProto* release_no_overlap_2d();
  void set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* no_overlap_2d);

  // optional .operations_research.sat.CumulativeConstraintProto cumulative = 22;
  bool has_cumulative() const;
  void clear_cumulative();
  static const int kCumulativeFieldNumber = 22;
  const ::operations_research::sat::CumulativeConstraintProto& cumulative() const;
  ::operations_research::sat::CumulativeConstraintProto* mutable_cumulative();
  ::operations_research::sat::CumulativeConstraintProto* release_cumulative();
  void set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* cumulative);

  ConstraintCase constraint_case() const;
  // @@protoc_insertion_point(class_scope:operations_research.sat.ConstraintProto)
 private:
  inline void set_has_bool_or();
  inline void set_has_bool_and();
  inline void set_has_bool_xor();
  inline void set_has_int_div();
  inline void set_has_int_mod();
  inline void set_has_int_max();
  inline void set_has_int_min();
  inline void set_has_int_prod();
  inline void set_has_linear();
  inline void set_has_all_diff();
  inline void set_has_element();
  inline void set_has_circuit();
  inline void set_has_table();
  inline void set_has_automata();
  inline void set_has_inverse();
  inline void set_has_interval();
  inline void set_has_no_overlap();
  inline void set_has_no_overlap_2d();
  inline void set_has_cumulative();

  inline bool has_constraint() const;
  void clear_constraint();
  inline void clear_has_constraint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enforcement_literal_;
  mutable int _enforcement_literal_cached_byte_size_;
  union ConstraintUnion {
    ConstraintUnion() {}
    ::operations_research::sat::BoolArgumentProto* bool_or_;
    ::operations_research::sat::BoolArgumentProto* bool_and_;
    ::operations_research::sat::BoolArgumentProto* bool_xor_;
    ::operations_research::sat::IntegerArgumentProto* int_div_;
    ::operations_research::sat::IntegerArgumentProto* int_mod_;
    ::operations_research::sat::IntegerArgumentProto* int_max_;
    ::operations_research::sat::IntegerArgumentProto* int_min_;
    ::operations_research::sat::IntegerArgumentProto* int_prod_;
    ::operations_research::sat::LinearConstraintProto* linear_;
    ::operations_research::sat::AllDifferentConstraintProto* all_diff_;
    ::operations_research::sat::ElementConstraintProto* element_;
    ::operations_research::sat::CircuitConstraintProto* circuit_;
    ::operations_research::sat::TableConstraintProto* table_;
    ::operations_research::sat::AutomataConstraintProto* automata_;
    ::operations_research::sat::InverseConstraintProto* inverse_;
    ::operations_research::sat::IntervalConstraintProto* interval_;
    ::operations_research::sat::NoOverlapConstraintProto* no_overlap_;
    ::operations_research::sat::NoOverlap2DConstraintProto* no_overlap_2d_;
    ::operations_research::sat::CumulativeConstraintProto* cumulative_;
  } constraint_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static ConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class CpObjectiveProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.CpObjectiveProto) */ {
 public:
  CpObjectiveProto();
  virtual ~CpObjectiveProto();

  CpObjectiveProto(const CpObjectiveProto& from);

  inline CpObjectiveProto& operator=(const CpObjectiveProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpObjectiveProto& default_instance();

  void Swap(CpObjectiveProto* other);

  // implements Message ----------------------------------------------

  inline CpObjectiveProto* New() const { return New(NULL); }

  CpObjectiveProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CpObjectiveProto& from);
  void MergeFrom(const CpObjectiveProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpObjectiveProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::google::protobuf::int32 vars(int index) const;
  void set_vars(int index, ::google::protobuf::int32 value);
  void add_vars(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vars();

  // repeated int64 coeffs = 4;
  int coeffs_size() const;
  void clear_coeffs();
  static const int kCoeffsFieldNumber = 4;
  ::google::protobuf::int64 coeffs(int index) const;
  void set_coeffs(int index, ::google::protobuf::int64 value);
  void add_coeffs(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      coeffs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_coeffs();

  // optional double offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  double offset() const;
  void set_offset(double value);

  // optional double scaling_factor = 3;
  void clear_scaling_factor();
  static const int kScalingFactorFieldNumber = 3;
  double scaling_factor() const;
  void set_scaling_factor(double value);

  // @@protoc_insertion_point(class_scope:operations_research.sat.CpObjectiveProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vars_;
  mutable int _vars_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > coeffs_;
  mutable int _coeffs_cached_byte_size_;
  double offset_;
  double scaling_factor_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static CpObjectiveProto* default_instance_;
};
// -------------------------------------------------------------------

class DecisionStrategyProto_AffineTransformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.DecisionStrategyProto.AffineTransformation) */ {
 public:
  DecisionStrategyProto_AffineTransformation();
  virtual ~DecisionStrategyProto_AffineTransformation();

  DecisionStrategyProto_AffineTransformation(const DecisionStrategyProto_AffineTransformation& from);

  inline DecisionStrategyProto_AffineTransformation& operator=(const DecisionStrategyProto_AffineTransformation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionStrategyProto_AffineTransformation& default_instance();

  void Swap(DecisionStrategyProto_AffineTransformation* other);

  // implements Message ----------------------------------------------

  inline DecisionStrategyProto_AffineTransformation* New() const { return New(NULL); }

  DecisionStrategyProto_AffineTransformation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecisionStrategyProto_AffineTransformation& from);
  void MergeFrom(const DecisionStrategyProto_AffineTransformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecisionStrategyProto_AffineTransformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  ::google::protobuf::int32 var() const;
  void set_var(::google::protobuf::int32 value);

  // optional int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional int64 positive_coeff = 3;
  void clear_positive_coeff();
  static const int kPositiveCoeffFieldNumber = 3;
  ::google::protobuf::int64 positive_coeff() const;
  void set_positive_coeff(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:operations_research.sat.DecisionStrategyProto.AffineTransformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 positive_coeff_;
  ::google::protobuf::int32 var_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static DecisionStrategyProto_AffineTransformation* default_instance_;
};
// -------------------------------------------------------------------

class DecisionStrategyProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.DecisionStrategyProto) */ {
 public:
  DecisionStrategyProto();
  virtual ~DecisionStrategyProto();

  DecisionStrategyProto(const DecisionStrategyProto& from);

  inline DecisionStrategyProto& operator=(const DecisionStrategyProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionStrategyProto& default_instance();

  void Swap(DecisionStrategyProto* other);

  // implements Message ----------------------------------------------

  inline DecisionStrategyProto* New() const { return New(NULL); }

  DecisionStrategyProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecisionStrategyProto& from);
  void MergeFrom(const DecisionStrategyProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecisionStrategyProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DecisionStrategyProto_AffineTransformation AffineTransformation;

  typedef DecisionStrategyProto_VariableSelectionStrategy VariableSelectionStrategy;
  static const VariableSelectionStrategy CHOOSE_FIRST =
    DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_FIRST;
  static const VariableSelectionStrategy CHOOSE_LOWEST_MIN =
    DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_LOWEST_MIN;
  static const VariableSelectionStrategy CHOOSE_HIGHEST_MAX =
    DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_HIGHEST_MAX;
  static const VariableSelectionStrategy CHOOSE_MIN_DOMAIN_SIZE =
    DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MIN_DOMAIN_SIZE;
  static const VariableSelectionStrategy CHOOSE_MAX_DOMAIN_SIZE =
    DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MAX_DOMAIN_SIZE;
  static inline bool VariableSelectionStrategy_IsValid(int value) {
    return DecisionStrategyProto_VariableSelectionStrategy_IsValid(value);
  }
  static const VariableSelectionStrategy VariableSelectionStrategy_MIN =
    DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MIN;
  static const VariableSelectionStrategy VariableSelectionStrategy_MAX =
    DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MAX;
  static const int VariableSelectionStrategy_ARRAYSIZE =
    DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VariableSelectionStrategy_descriptor() {
    return DecisionStrategyProto_VariableSelectionStrategy_descriptor();
  }
  static inline const ::std::string& VariableSelectionStrategy_Name(VariableSelectionStrategy value) {
    return DecisionStrategyProto_VariableSelectionStrategy_Name(value);
  }
  static inline bool VariableSelectionStrategy_Parse(const ::std::string& name,
      VariableSelectionStrategy* value) {
    return DecisionStrategyProto_VariableSelectionStrategy_Parse(name, value);
  }

  typedef DecisionStrategyProto_DomainReductionStrategy DomainReductionStrategy;
  static const DomainReductionStrategy SELECT_MIN_VALUE =
    DecisionStrategyProto_DomainReductionStrategy_SELECT_MIN_VALUE;
  static const DomainReductionStrategy SELECT_MAX_VALUE =
    DecisionStrategyProto_DomainReductionStrategy_SELECT_MAX_VALUE;
  static const DomainReductionStrategy SELECT_LOWER_HALF =
    DecisionStrategyProto_DomainReductionStrategy_SELECT_LOWER_HALF;
  static const DomainReductionStrategy SELECT_UPPER_HALF =
    DecisionStrategyProto_DomainReductionStrategy_SELECT_UPPER_HALF;
  static inline bool DomainReductionStrategy_IsValid(int value) {
    return DecisionStrategyProto_DomainReductionStrategy_IsValid(value);
  }
  static const DomainReductionStrategy DomainReductionStrategy_MIN =
    DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MIN;
  static const DomainReductionStrategy DomainReductionStrategy_MAX =
    DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MAX;
  static const int DomainReductionStrategy_ARRAYSIZE =
    DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DomainReductionStrategy_descriptor() {
    return DecisionStrategyProto_DomainReductionStrategy_descriptor();
  }
  static inline const ::std::string& DomainReductionStrategy_Name(DomainReductionStrategy value) {
    return DecisionStrategyProto_DomainReductionStrategy_Name(value);
  }
  static inline bool DomainReductionStrategy_Parse(const ::std::string& name,
      DomainReductionStrategy* value) {
    return DecisionStrategyProto_DomainReductionStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 variables = 1;
  int variables_size() const;
  void clear_variables();
  static const int kVariablesFieldNumber = 1;
  ::google::protobuf::int32 variables(int index) const;
  void set_variables(int index, ::google::protobuf::int32 value);
  void add_variables(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      variables() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_variables();

  // optional .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
  void clear_variable_selection_strategy();
  static const int kVariableSelectionStrategyFieldNumber = 2;
  ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy variable_selection_strategy() const;
  void set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value);

  // optional .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
  void clear_domain_reduction_strategy();
  static const int kDomainReductionStrategyFieldNumber = 3;
  ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy domain_reduction_strategy() const;
  void set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value);

  // repeated .operations_research.sat.DecisionStrategyProto.AffineTransformation transformations = 4;
  int transformations_size() const;
  void clear_transformations();
  static const int kTransformationsFieldNumber = 4;
  const ::operations_research::sat::DecisionStrategyProto_AffineTransformation& transformations(int index) const;
  ::operations_research::sat::DecisionStrategyProto_AffineTransformation* mutable_transformations(int index);
  ::operations_research::sat::DecisionStrategyProto_AffineTransformation* add_transformations();
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >*
      mutable_transformations();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >&
      transformations() const;

  // @@protoc_insertion_point(class_scope:operations_research.sat.DecisionStrategyProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > variables_;
  mutable int _variables_cached_byte_size_;
  int variable_selection_strategy_;
  int domain_reduction_strategy_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto_AffineTransformation > transformations_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static DecisionStrategyProto* default_instance_;
};
// -------------------------------------------------------------------

class CpModelProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.CpModelProto) */ {
 public:
  CpModelProto();
  virtual ~CpModelProto();

  CpModelProto(const CpModelProto& from);

  inline CpModelProto& operator=(const CpModelProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpModelProto& default_instance();

  void Swap(CpModelProto* other);

  // implements Message ----------------------------------------------

  inline CpModelProto* New() const { return New(NULL); }

  CpModelProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CpModelProto& from);
  void MergeFrom(const CpModelProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpModelProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .operations_research.sat.IntegerVariableProto variables = 2;
  int variables_size() const;
  void clear_variables();
  static const int kVariablesFieldNumber = 2;
  const ::operations_research::sat::IntegerVariableProto& variables(int index) const;
  ::operations_research::sat::IntegerVariableProto* mutable_variables(int index);
  ::operations_research::sat::IntegerVariableProto* add_variables();
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto >*
      mutable_variables();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto >&
      variables() const;

  // repeated .operations_research.sat.ConstraintProto constraints = 3;
  int constraints_size() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 3;
  const ::operations_research::sat::ConstraintProto& constraints(int index) const;
  ::operations_research::sat::ConstraintProto* mutable_constraints(int index);
  ::operations_research::sat::ConstraintProto* add_constraints();
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto >*
      mutable_constraints();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto >&
      constraints() const;

  // optional .operations_research.sat.CpObjectiveProto objective = 4;
  bool has_objective() const;
  void clear_objective();
  static const int kObjectiveFieldNumber = 4;
  const ::operations_research::sat::CpObjectiveProto& objective() const;
  ::operations_research::sat::CpObjectiveProto* mutable_objective();
  ::operations_research::sat::CpObjectiveProto* release_objective();
  void set_allocated_objective(::operations_research::sat::CpObjectiveProto* objective);

  // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
  int search_strategy_size() const;
  void clear_search_strategy();
  static const int kSearchStrategyFieldNumber = 5;
  const ::operations_research::sat::DecisionStrategyProto& search_strategy(int index) const;
  ::operations_research::sat::DecisionStrategyProto* mutable_search_strategy(int index);
  ::operations_research::sat::DecisionStrategyProto* add_search_strategy();
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto >*
      mutable_search_strategy();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto >&
      search_strategy() const;

  // @@protoc_insertion_point(class_scope:operations_research.sat.CpModelProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto > variables_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto > constraints_;
  ::operations_research::sat::CpObjectiveProto* objective_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto > search_strategy_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static CpModelProto* default_instance_;
};
// -------------------------------------------------------------------

class CpSolverResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.CpSolverResponse) */ {
 public:
  CpSolverResponse();
  virtual ~CpSolverResponse();

  CpSolverResponse(const CpSolverResponse& from);

  inline CpSolverResponse& operator=(const CpSolverResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpSolverResponse& default_instance();

  void Swap(CpSolverResponse* other);

  // implements Message ----------------------------------------------

  inline CpSolverResponse* New() const { return New(NULL); }

  CpSolverResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CpSolverResponse& from);
  void MergeFrom(const CpSolverResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpSolverResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .operations_research.sat.CpSolverStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::operations_research::sat::CpSolverStatus status() const;
  void set_status(::operations_research::sat::CpSolverStatus value);

  // repeated int64 solution = 2;
  int solution_size() const;
  void clear_solution();
  static const int kSolutionFieldNumber = 2;
  ::google::protobuf::int64 solution(int index) const;
  void set_solution(int index, ::google::protobuf::int64 value);
  void add_solution(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      solution() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_solution();

  // repeated int64 solution_lower_bounds = 18;
  int solution_lower_bounds_size() const;
  void clear_solution_lower_bounds();
  static const int kSolutionLowerBoundsFieldNumber = 18;
  ::google::protobuf::int64 solution_lower_bounds(int index) const;
  void set_solution_lower_bounds(int index, ::google::protobuf::int64 value);
  void add_solution_lower_bounds(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      solution_lower_bounds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_solution_lower_bounds();

  // repeated int64 solution_upper_bounds = 19;
  int solution_upper_bounds_size() const;
  void clear_solution_upper_bounds();
  static const int kSolutionUpperBoundsFieldNumber = 19;
  ::google::protobuf::int64 solution_upper_bounds(int index) const;
  void set_solution_upper_bounds(int index, ::google::protobuf::int64 value);
  void add_solution_upper_bounds(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      solution_upper_bounds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_solution_upper_bounds();

  // optional double objective_value = 3;
  void clear_objective_value();
  static const int kObjectiveValueFieldNumber = 3;
  double objective_value() const;
  void set_objective_value(double value);

  // optional double best_objective_bound = 4;
  void clear_best_objective_bound();
  static const int kBestObjectiveBoundFieldNumber = 4;
  double best_objective_bound() const;
  void set_best_objective_bound(double value);

  // optional bool all_solutions_were_found = 5;
  void clear_all_solutions_were_found();
  static const int kAllSolutionsWereFoundFieldNumber = 5;
  bool all_solutions_were_found() const;
  void set_all_solutions_were_found(bool value);

  // optional int64 num_booleans = 10;
  void clear_num_booleans();
  static const int kNumBooleansFieldNumber = 10;
  ::google::protobuf::int64 num_booleans() const;
  void set_num_booleans(::google::protobuf::int64 value);

  // optional int64 num_conflicts = 11;
  void clear_num_conflicts();
  static const int kNumConflictsFieldNumber = 11;
  ::google::protobuf::int64 num_conflicts() const;
  void set_num_conflicts(::google::protobuf::int64 value);

  // optional int64 num_branches = 12;
  void clear_num_branches();
  static const int kNumBranchesFieldNumber = 12;
  ::google::protobuf::int64 num_branches() const;
  void set_num_branches(::google::protobuf::int64 value);

  // optional int64 num_binary_propagations = 13;
  void clear_num_binary_propagations();
  static const int kNumBinaryPropagationsFieldNumber = 13;
  ::google::protobuf::int64 num_binary_propagations() const;
  void set_num_binary_propagations(::google::protobuf::int64 value);

  // optional int64 num_integer_propagations = 14;
  void clear_num_integer_propagations();
  static const int kNumIntegerPropagationsFieldNumber = 14;
  ::google::protobuf::int64 num_integer_propagations() const;
  void set_num_integer_propagations(::google::protobuf::int64 value);

  // optional double wall_time = 15;
  void clear_wall_time();
  static const int kWallTimeFieldNumber = 15;
  double wall_time() const;
  void set_wall_time(double value);

  // optional double user_time = 16;
  void clear_user_time();
  static const int kUserTimeFieldNumber = 16;
  double user_time() const;
  void set_user_time(double value);

  // optional double deterministic_time = 17;
  void clear_deterministic_time();
  static const int kDeterministicTimeFieldNumber = 17;
  double deterministic_time() const;
  void set_deterministic_time(double value);

  // @@protoc_insertion_point(class_scope:operations_research.sat.CpSolverResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > solution_;
  mutable int _solution_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > solution_lower_bounds_;
  mutable int _solution_lower_bounds_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > solution_upper_bounds_;
  mutable int _solution_upper_bounds_cached_byte_size_;
  int status_;
  bool all_solutions_were_found_;
  double objective_value_;
  double best_objective_bound_;
  ::google::protobuf::int64 num_booleans_;
  ::google::protobuf::int64 num_conflicts_;
  ::google::protobuf::int64 num_branches_;
  ::google::protobuf::int64 num_binary_propagations_;
  ::google::protobuf::int64 num_integer_propagations_;
  double wall_time_;
  double user_time_;
  double deterministic_time_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_AssignDesc_ortools_2fsat_2fcp_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_ortools_2fsat_2fcp_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static CpSolverResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// IntegerVariableProto

// optional string name = 1;
inline void IntegerVariableProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IntegerVariableProto::name() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerVariableProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IntegerVariableProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerVariableProto.name)
}
inline void IntegerVariableProto::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:operations_research.sat.IntegerVariableProto.name)
}
inline void IntegerVariableProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.IntegerVariableProto.name)
}
inline ::std::string* IntegerVariableProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:operations_research.sat.IntegerVariableProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IntegerVariableProto::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.sat.IntegerVariableProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IntegerVariableProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.IntegerVariableProto.name)
}

// repeated int64 domain = 2;
inline int IntegerVariableProto::domain_size() const {
  return domain_.size();
}
inline void IntegerVariableProto::clear_domain() {
  domain_.Clear();
}
inline ::google::protobuf::int64 IntegerVariableProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerVariableProto.domain)
  return domain_.Get(index);
}
inline void IntegerVariableProto::set_domain(int index, ::google::protobuf::int64 value) {
  domain_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerVariableProto.domain)
}
inline void IntegerVariableProto::add_domain(::google::protobuf::int64 value) {
  domain_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.IntegerVariableProto.domain)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
IntegerVariableProto::domain() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.IntegerVariableProto.domain)
  return domain_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
IntegerVariableProto::mutable_domain() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.IntegerVariableProto.domain)
  return &domain_;
}

// -------------------------------------------------------------------

// BoolArgumentProto

// repeated int32 literals = 1;
inline int BoolArgumentProto::literals_size() const {
  return literals_.size();
}
inline void BoolArgumentProto::clear_literals() {
  literals_.Clear();
}
inline ::google::protobuf::int32 BoolArgumentProto::literals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.BoolArgumentProto.literals)
  return literals_.Get(index);
}
inline void BoolArgumentProto::set_literals(int index, ::google::protobuf::int32 value) {
  literals_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.BoolArgumentProto.literals)
}
inline void BoolArgumentProto::add_literals(::google::protobuf::int32 value) {
  literals_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.BoolArgumentProto.literals)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BoolArgumentProto::literals() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.BoolArgumentProto.literals)
  return literals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BoolArgumentProto::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.BoolArgumentProto.literals)
  return &literals_;
}

// -------------------------------------------------------------------

// IntegerArgumentProto

// optional int32 target = 1;
inline void IntegerArgumentProto::clear_target() {
  target_ = 0;
}
inline ::google::protobuf::int32 IntegerArgumentProto::target() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerArgumentProto.target)
  return target_;
}
inline void IntegerArgumentProto::set_target(::google::protobuf::int32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerArgumentProto.target)
}

// repeated int32 vars = 2;
inline int IntegerArgumentProto::vars_size() const {
  return vars_.size();
}
inline void IntegerArgumentProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 IntegerArgumentProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerArgumentProto.vars)
  return vars_.Get(index);
}
inline void IntegerArgumentProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerArgumentProto.vars)
}
inline void IntegerArgumentProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.IntegerArgumentProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IntegerArgumentProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.IntegerArgumentProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IntegerArgumentProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.IntegerArgumentProto.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// AllDifferentConstraintProto

// repeated int32 vars = 1;
inline int AllDifferentConstraintProto::vars_size() const {
  return vars_.size();
}
inline void AllDifferentConstraintProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 AllDifferentConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AllDifferentConstraintProto.vars)
  return vars_.Get(index);
}
inline void AllDifferentConstraintProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AllDifferentConstraintProto.vars)
}
inline void AllDifferentConstraintProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AllDifferentConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AllDifferentConstraintProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AllDifferentConstraintProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AllDifferentConstraintProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AllDifferentConstraintProto.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// LinearConstraintProto

// repeated int32 vars = 1;
inline int LinearConstraintProto::vars_size() const {
  return vars_.size();
}
inline void LinearConstraintProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 LinearConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.vars)
  return vars_.Get(index);
}
inline void LinearConstraintProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.vars)
}
inline void LinearConstraintProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LinearConstraintProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LinearConstraintProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.vars)
  return &vars_;
}

// repeated int64 coeffs = 2;
inline int LinearConstraintProto::coeffs_size() const {
  return coeffs_.size();
}
inline void LinearConstraintProto::clear_coeffs() {
  coeffs_.Clear();
}
inline ::google::protobuf::int64 LinearConstraintProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.coeffs)
  return coeffs_.Get(index);
}
inline void LinearConstraintProto::set_coeffs(int index, ::google::protobuf::int64 value) {
  coeffs_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.coeffs)
}
inline void LinearConstraintProto::add_coeffs(::google::protobuf::int64 value) {
  coeffs_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.coeffs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LinearConstraintProto::coeffs() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.coeffs)
  return coeffs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LinearConstraintProto::mutable_coeffs() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.coeffs)
  return &coeffs_;
}

// repeated int64 domain = 3;
inline int LinearConstraintProto::domain_size() const {
  return domain_.size();
}
inline void LinearConstraintProto::clear_domain() {
  domain_.Clear();
}
inline ::google::protobuf::int64 LinearConstraintProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.domain)
  return domain_.Get(index);
}
inline void LinearConstraintProto::set_domain(int index, ::google::protobuf::int64 value) {
  domain_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.domain)
}
inline void LinearConstraintProto::add_domain(::google::protobuf::int64 value) {
  domain_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.domain)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LinearConstraintProto::domain() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.domain)
  return domain_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LinearConstraintProto::mutable_domain() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.domain)
  return &domain_;
}

// -------------------------------------------------------------------

// ElementConstraintProto

// optional int32 index = 1;
inline void ElementConstraintProto::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 ElementConstraintProto::index() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.index)
  return index_;
}
inline void ElementConstraintProto::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.index)
}

// optional int32 target = 2;
inline void ElementConstraintProto::clear_target() {
  target_ = 0;
}
inline ::google::protobuf::int32 ElementConstraintProto::target() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.target)
  return target_;
}
inline void ElementConstraintProto::set_target(::google::protobuf::int32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.target)
}

// repeated int32 vars = 3;
inline int ElementConstraintProto::vars_size() const {
  return vars_.size();
}
inline void ElementConstraintProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 ElementConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.vars)
  return vars_.Get(index);
}
inline void ElementConstraintProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.vars)
}
inline void ElementConstraintProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.ElementConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ElementConstraintProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.ElementConstraintProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ElementConstraintProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ElementConstraintProto.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// IntervalConstraintProto

// optional int32 start = 1;
inline void IntervalConstraintProto::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 IntervalConstraintProto::start() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.start)
  return start_;
}
inline void IntervalConstraintProto::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.IntervalConstraintProto.start)
}

// optional int32 end = 2;
inline void IntervalConstraintProto::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 IntervalConstraintProto::end() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.end)
  return end_;
}
inline void IntervalConstraintProto::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.IntervalConstraintProto.end)
}

// optional int32 size = 3;
inline void IntervalConstraintProto::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 IntervalConstraintProto::size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.size)
  return size_;
}
inline void IntervalConstraintProto::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.IntervalConstraintProto.size)
}

// -------------------------------------------------------------------

// NoOverlapConstraintProto

// repeated int32 intervals = 1;
inline int NoOverlapConstraintProto::intervals_size() const {
  return intervals_.size();
}
inline void NoOverlapConstraintProto::clear_intervals() {
  intervals_.Clear();
}
inline ::google::protobuf::int32 NoOverlapConstraintProto::intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlapConstraintProto.intervals)
  return intervals_.Get(index);
}
inline void NoOverlapConstraintProto::set_intervals(int index, ::google::protobuf::int32 value) {
  intervals_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlapConstraintProto.intervals)
}
inline void NoOverlapConstraintProto::add_intervals(::google::protobuf::int32 value) {
  intervals_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlapConstraintProto.intervals)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NoOverlapConstraintProto::intervals() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlapConstraintProto.intervals)
  return intervals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NoOverlapConstraintProto::mutable_intervals() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlapConstraintProto.intervals)
  return &intervals_;
}

// -------------------------------------------------------------------

// NoOverlap2DConstraintProto

// repeated int32 x_intervals = 1;
inline int NoOverlap2DConstraintProto::x_intervals_size() const {
  return x_intervals_.size();
}
inline void NoOverlap2DConstraintProto::clear_x_intervals() {
  x_intervals_.Clear();
}
inline ::google::protobuf::int32 NoOverlap2DConstraintProto::x_intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  return x_intervals_.Get(index);
}
inline void NoOverlap2DConstraintProto::set_x_intervals(int index, ::google::protobuf::int32 value) {
  x_intervals_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
}
inline void NoOverlap2DConstraintProto::add_x_intervals(::google::protobuf::int32 value) {
  x_intervals_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NoOverlap2DConstraintProto::x_intervals() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  return x_intervals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NoOverlap2DConstraintProto::mutable_x_intervals() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  return &x_intervals_;
}

// repeated int32 y_intervals = 2;
inline int NoOverlap2DConstraintProto::y_intervals_size() const {
  return y_intervals_.size();
}
inline void NoOverlap2DConstraintProto::clear_y_intervals() {
  y_intervals_.Clear();
}
inline ::google::protobuf::int32 NoOverlap2DConstraintProto::y_intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  return y_intervals_.Get(index);
}
inline void NoOverlap2DConstraintProto::set_y_intervals(int index, ::google::protobuf::int32 value) {
  y_intervals_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
}
inline void NoOverlap2DConstraintProto::add_y_intervals(::google::protobuf::int32 value) {
  y_intervals_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NoOverlap2DConstraintProto::y_intervals() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  return y_intervals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NoOverlap2DConstraintProto::mutable_y_intervals() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  return &y_intervals_;
}

// -------------------------------------------------------------------

// CumulativeConstraintProto

// optional int32 capacity = 1;
inline void CumulativeConstraintProto::clear_capacity() {
  capacity_ = 0;
}
inline ::google::protobuf::int32 CumulativeConstraintProto::capacity() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.capacity)
  return capacity_;
}
inline void CumulativeConstraintProto::set_capacity(::google::protobuf::int32 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CumulativeConstraintProto.capacity)
}

// repeated int32 intervals = 2;
inline int CumulativeConstraintProto::intervals_size() const {
  return intervals_.size();
}
inline void CumulativeConstraintProto::clear_intervals() {
  intervals_.Clear();
}
inline ::google::protobuf::int32 CumulativeConstraintProto::intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.intervals)
  return intervals_.Get(index);
}
inline void CumulativeConstraintProto::set_intervals(int index, ::google::protobuf::int32 value) {
  intervals_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CumulativeConstraintProto.intervals)
}
inline void CumulativeConstraintProto::add_intervals(::google::protobuf::int32 value) {
  intervals_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CumulativeConstraintProto.intervals)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CumulativeConstraintProto::intervals() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CumulativeConstraintProto.intervals)
  return intervals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CumulativeConstraintProto::mutable_intervals() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CumulativeConstraintProto.intervals)
  return &intervals_;
}

// repeated int32 demands = 3;
inline int CumulativeConstraintProto::demands_size() const {
  return demands_.size();
}
inline void CumulativeConstraintProto::clear_demands() {
  demands_.Clear();
}
inline ::google::protobuf::int32 CumulativeConstraintProto::demands(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.demands)
  return demands_.Get(index);
}
inline void CumulativeConstraintProto::set_demands(int index, ::google::protobuf::int32 value) {
  demands_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CumulativeConstraintProto.demands)
}
inline void CumulativeConstraintProto::add_demands(::google::protobuf::int32 value) {
  demands_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CumulativeConstraintProto.demands)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CumulativeConstraintProto::demands() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CumulativeConstraintProto.demands)
  return demands_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CumulativeConstraintProto::mutable_demands() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CumulativeConstraintProto.demands)
  return &demands_;
}

// -------------------------------------------------------------------

// CircuitConstraintProto

// repeated int32 nexts = 2;
inline int CircuitConstraintProto::nexts_size() const {
  return nexts_.size();
}
inline void CircuitConstraintProto::clear_nexts() {
  nexts_.Clear();
}
inline ::google::protobuf::int32 CircuitConstraintProto::nexts(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CircuitConstraintProto.nexts)
  return nexts_.Get(index);
}
inline void CircuitConstraintProto::set_nexts(int index, ::google::protobuf::int32 value) {
  nexts_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CircuitConstraintProto.nexts)
}
inline void CircuitConstraintProto::add_nexts(::google::protobuf::int32 value) {
  nexts_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CircuitConstraintProto.nexts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CircuitConstraintProto::nexts() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CircuitConstraintProto.nexts)
  return nexts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CircuitConstraintProto::mutable_nexts() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CircuitConstraintProto.nexts)
  return &nexts_;
}

// -------------------------------------------------------------------

// TableConstraintProto

// repeated int32 vars = 1;
inline int TableConstraintProto::vars_size() const {
  return vars_.size();
}
inline void TableConstraintProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 TableConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.vars)
  return vars_.Get(index);
}
inline void TableConstraintProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.vars)
}
inline void TableConstraintProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.TableConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TableConstraintProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.TableConstraintProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TableConstraintProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.TableConstraintProto.vars)
  return &vars_;
}

// repeated int64 values = 2;
inline int TableConstraintProto::values_size() const {
  return values_.size();
}
inline void TableConstraintProto::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 TableConstraintProto::values(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.values)
  return values_.Get(index);
}
inline void TableConstraintProto::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.values)
}
inline void TableConstraintProto::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.TableConstraintProto.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TableConstraintProto::values() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.TableConstraintProto.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TableConstraintProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.TableConstraintProto.values)
  return &values_;
}

// optional bool negated = 3;
inline void TableConstraintProto::clear_negated() {
  negated_ = false;
}
inline bool TableConstraintProto::negated() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.negated)
  return negated_;
}
inline void TableConstraintProto::set_negated(bool value) {
  
  negated_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.negated)
}

// -------------------------------------------------------------------

// InverseConstraintProto

// repeated int32 f_direct = 1;
inline int InverseConstraintProto::f_direct_size() const {
  return f_direct_.size();
}
inline void InverseConstraintProto::clear_f_direct() {
  f_direct_.Clear();
}
inline ::google::protobuf::int32 InverseConstraintProto::f_direct(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.InverseConstraintProto.f_direct)
  return f_direct_.Get(index);
}
inline void InverseConstraintProto::set_f_direct(int index, ::google::protobuf::int32 value) {
  f_direct_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.InverseConstraintProto.f_direct)
}
inline void InverseConstraintProto::add_f_direct(::google::protobuf::int32 value) {
  f_direct_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.InverseConstraintProto.f_direct)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InverseConstraintProto::f_direct() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.InverseConstraintProto.f_direct)
  return f_direct_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InverseConstraintProto::mutable_f_direct() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.InverseConstraintProto.f_direct)
  return &f_direct_;
}

// repeated int32 f_inverse = 2;
inline int InverseConstraintProto::f_inverse_size() const {
  return f_inverse_.size();
}
inline void InverseConstraintProto::clear_f_inverse() {
  f_inverse_.Clear();
}
inline ::google::protobuf::int32 InverseConstraintProto::f_inverse(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.InverseConstraintProto.f_inverse)
  return f_inverse_.Get(index);
}
inline void InverseConstraintProto::set_f_inverse(int index, ::google::protobuf::int32 value) {
  f_inverse_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.InverseConstraintProto.f_inverse)
}
inline void InverseConstraintProto::add_f_inverse(::google::protobuf::int32 value) {
  f_inverse_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.InverseConstraintProto.f_inverse)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InverseConstraintProto::f_inverse() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.InverseConstraintProto.f_inverse)
  return f_inverse_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InverseConstraintProto::mutable_f_inverse() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.InverseConstraintProto.f_inverse)
  return &f_inverse_;
}

// -------------------------------------------------------------------

// AutomataConstraintProto

// optional int64 starting_state = 2;
inline void AutomataConstraintProto::clear_starting_state() {
  starting_state_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AutomataConstraintProto::starting_state() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.starting_state)
  return starting_state_;
}
inline void AutomataConstraintProto::set_starting_state(::google::protobuf::int64 value) {
  
  starting_state_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.starting_state)
}

// repeated int64 final_states = 3;
inline int AutomataConstraintProto::final_states_size() const {
  return final_states_.size();
}
inline void AutomataConstraintProto::clear_final_states() {
  final_states_.Clear();
}
inline ::google::protobuf::int64 AutomataConstraintProto::final_states(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.final_states)
  return final_states_.Get(index);
}
inline void AutomataConstraintProto::set_final_states(int index, ::google::protobuf::int64 value) {
  final_states_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.final_states)
}
inline void AutomataConstraintProto::add_final_states(::google::protobuf::int64 value) {
  final_states_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomataConstraintProto.final_states)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AutomataConstraintProto::final_states() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomataConstraintProto.final_states)
  return final_states_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AutomataConstraintProto::mutable_final_states() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomataConstraintProto.final_states)
  return &final_states_;
}

// repeated int64 transition_tail = 4;
inline int AutomataConstraintProto::transition_tail_size() const {
  return transition_tail_.size();
}
inline void AutomataConstraintProto::clear_transition_tail() {
  transition_tail_.Clear();
}
inline ::google::protobuf::int64 AutomataConstraintProto::transition_tail(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.transition_tail)
  return transition_tail_.Get(index);
}
inline void AutomataConstraintProto::set_transition_tail(int index, ::google::protobuf::int64 value) {
  transition_tail_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.transition_tail)
}
inline void AutomataConstraintProto::add_transition_tail(::google::protobuf::int64 value) {
  transition_tail_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomataConstraintProto.transition_tail)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AutomataConstraintProto::transition_tail() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomataConstraintProto.transition_tail)
  return transition_tail_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AutomataConstraintProto::mutable_transition_tail() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomataConstraintProto.transition_tail)
  return &transition_tail_;
}

// repeated int64 transition_head = 5;
inline int AutomataConstraintProto::transition_head_size() const {
  return transition_head_.size();
}
inline void AutomataConstraintProto::clear_transition_head() {
  transition_head_.Clear();
}
inline ::google::protobuf::int64 AutomataConstraintProto::transition_head(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.transition_head)
  return transition_head_.Get(index);
}
inline void AutomataConstraintProto::set_transition_head(int index, ::google::protobuf::int64 value) {
  transition_head_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.transition_head)
}
inline void AutomataConstraintProto::add_transition_head(::google::protobuf::int64 value) {
  transition_head_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomataConstraintProto.transition_head)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AutomataConstraintProto::transition_head() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomataConstraintProto.transition_head)
  return transition_head_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AutomataConstraintProto::mutable_transition_head() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomataConstraintProto.transition_head)
  return &transition_head_;
}

// repeated int64 transition_label = 6;
inline int AutomataConstraintProto::transition_label_size() const {
  return transition_label_.size();
}
inline void AutomataConstraintProto::clear_transition_label() {
  transition_label_.Clear();
}
inline ::google::protobuf::int64 AutomataConstraintProto::transition_label(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.transition_label)
  return transition_label_.Get(index);
}
inline void AutomataConstraintProto::set_transition_label(int index, ::google::protobuf::int64 value) {
  transition_label_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.transition_label)
}
inline void AutomataConstraintProto::add_transition_label(::google::protobuf::int64 value) {
  transition_label_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomataConstraintProto.transition_label)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AutomataConstraintProto::transition_label() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomataConstraintProto.transition_label)
  return transition_label_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AutomataConstraintProto::mutable_transition_label() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomataConstraintProto.transition_label)
  return &transition_label_;
}

// repeated int32 vars = 7;
inline int AutomataConstraintProto::vars_size() const {
  return vars_.size();
}
inline void AutomataConstraintProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 AutomataConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomataConstraintProto.vars)
  return vars_.Get(index);
}
inline void AutomataConstraintProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomataConstraintProto.vars)
}
inline void AutomataConstraintProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomataConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AutomataConstraintProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomataConstraintProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AutomataConstraintProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomataConstraintProto.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// ConstraintProto

// optional string name = 1;
inline void ConstraintProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConstraintProto::name() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConstraintProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ConstraintProto.name)
}
inline void ConstraintProto::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:operations_research.sat.ConstraintProto.name)
}
inline void ConstraintProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.ConstraintProto.name)
}
inline ::std::string* ConstraintProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConstraintProto::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConstraintProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.name)
}

// repeated int32 enforcement_literal = 2;
inline int ConstraintProto::enforcement_literal_size() const {
  return enforcement_literal_.size();
}
inline void ConstraintProto::clear_enforcement_literal() {
  enforcement_literal_.Clear();
}
inline ::google::protobuf::int32 ConstraintProto::enforcement_literal(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.enforcement_literal)
  return enforcement_literal_.Get(index);
}
inline void ConstraintProto::set_enforcement_literal(int index, ::google::protobuf::int32 value) {
  enforcement_literal_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ConstraintProto.enforcement_literal)
}
inline void ConstraintProto::add_enforcement_literal(::google::protobuf::int32 value) {
  enforcement_literal_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.ConstraintProto.enforcement_literal)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConstraintProto::enforcement_literal() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.ConstraintProto.enforcement_literal)
  return enforcement_literal_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConstraintProto::mutable_enforcement_literal() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ConstraintProto.enforcement_literal)
  return &enforcement_literal_;
}

// optional .operations_research.sat.BoolArgumentProto bool_or = 3;
inline bool ConstraintProto::has_bool_or() const {
  return constraint_case() == kBoolOr;
}
inline void ConstraintProto::set_has_bool_or() {
  _oneof_case_[0] = kBoolOr;
}
inline void ConstraintProto::clear_bool_or() {
  if (has_bool_or()) {
    delete constraint_.bool_or_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_or() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_or)
  return has_bool_or()
      ? *constraint_.bool_or_
      : ::operations_research::sat::BoolArgumentProto::default_instance();
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::mutable_bool_or() {
  if (!has_bool_or()) {
    clear_constraint();
    set_has_bool_or();
    constraint_.bool_or_ = new ::operations_research::sat::BoolArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_or)
  return constraint_.bool_or_;
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::release_bool_or() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_or)
  if (has_bool_or()) {
    clear_has_constraint();
    ::operations_research::sat::BoolArgumentProto* temp = constraint_.bool_or_;
    constraint_.bool_or_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* bool_or) {
  clear_constraint();
  if (bool_or) {
    set_has_bool_or();
    constraint_.bool_or_ = bool_or;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_or)
}

// optional .operations_research.sat.BoolArgumentProto bool_and = 4;
inline bool ConstraintProto::has_bool_and() const {
  return constraint_case() == kBoolAnd;
}
inline void ConstraintProto::set_has_bool_and() {
  _oneof_case_[0] = kBoolAnd;
}
inline void ConstraintProto::clear_bool_and() {
  if (has_bool_and()) {
    delete constraint_.bool_and_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_and() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_and)
  return has_bool_and()
      ? *constraint_.bool_and_
      : ::operations_research::sat::BoolArgumentProto::default_instance();
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::mutable_bool_and() {
  if (!has_bool_and()) {
    clear_constraint();
    set_has_bool_and();
    constraint_.bool_and_ = new ::operations_research::sat::BoolArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_and)
  return constraint_.bool_and_;
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::release_bool_and() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_and)
  if (has_bool_and()) {
    clear_has_constraint();
    ::operations_research::sat::BoolArgumentProto* temp = constraint_.bool_and_;
    constraint_.bool_and_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* bool_and) {
  clear_constraint();
  if (bool_and) {
    set_has_bool_and();
    constraint_.bool_and_ = bool_and;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_and)
}

// optional .operations_research.sat.BoolArgumentProto bool_xor = 5;
inline bool ConstraintProto::has_bool_xor() const {
  return constraint_case() == kBoolXor;
}
inline void ConstraintProto::set_has_bool_xor() {
  _oneof_case_[0] = kBoolXor;
}
inline void ConstraintProto::clear_bool_xor() {
  if (has_bool_xor()) {
    delete constraint_.bool_xor_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_xor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_xor)
  return has_bool_xor()
      ? *constraint_.bool_xor_
      : ::operations_research::sat::BoolArgumentProto::default_instance();
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::mutable_bool_xor() {
  if (!has_bool_xor()) {
    clear_constraint();
    set_has_bool_xor();
    constraint_.bool_xor_ = new ::operations_research::sat::BoolArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_xor)
  return constraint_.bool_xor_;
}
inline ::operations_research::sat::BoolArgumentProto* ConstraintProto::release_bool_xor() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_xor)
  if (has_bool_xor()) {
    clear_has_constraint();
    ::operations_research::sat::BoolArgumentProto* temp = constraint_.bool_xor_;
    constraint_.bool_xor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* bool_xor) {
  clear_constraint();
  if (bool_xor) {
    set_has_bool_xor();
    constraint_.bool_xor_ = bool_xor;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_xor)
}

// optional .operations_research.sat.IntegerArgumentProto int_div = 7;
inline bool ConstraintProto::has_int_div() const {
  return constraint_case() == kIntDiv;
}
inline void ConstraintProto::set_has_int_div() {
  _oneof_case_[0] = kIntDiv;
}
inline void ConstraintProto::clear_int_div() {
  if (has_int_div()) {
    delete constraint_.int_div_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntegerArgumentProto& ConstraintProto::int_div() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_div)
  return has_int_div()
      ? *constraint_.int_div_
      : ::operations_research::sat::IntegerArgumentProto::default_instance();
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::mutable_int_div() {
  if (!has_int_div()) {
    clear_constraint();
    set_has_int_div();
    constraint_.int_div_ = new ::operations_research::sat::IntegerArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_div)
  return constraint_.int_div_;
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::release_int_div() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_div)
  if (has_int_div()) {
    clear_has_constraint();
    ::operations_research::sat::IntegerArgumentProto* temp = constraint_.int_div_;
    constraint_.int_div_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_int_div(::operations_research::sat::IntegerArgumentProto* int_div) {
  clear_constraint();
  if (int_div) {
    set_has_int_div();
    constraint_.int_div_ = int_div;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_div)
}

// optional .operations_research.sat.IntegerArgumentProto int_mod = 8;
inline bool ConstraintProto::has_int_mod() const {
  return constraint_case() == kIntMod;
}
inline void ConstraintProto::set_has_int_mod() {
  _oneof_case_[0] = kIntMod;
}
inline void ConstraintProto::clear_int_mod() {
  if (has_int_mod()) {
    delete constraint_.int_mod_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntegerArgumentProto& ConstraintProto::int_mod() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_mod)
  return has_int_mod()
      ? *constraint_.int_mod_
      : ::operations_research::sat::IntegerArgumentProto::default_instance();
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::mutable_int_mod() {
  if (!has_int_mod()) {
    clear_constraint();
    set_has_int_mod();
    constraint_.int_mod_ = new ::operations_research::sat::IntegerArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_mod)
  return constraint_.int_mod_;
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::release_int_mod() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_mod)
  if (has_int_mod()) {
    clear_has_constraint();
    ::operations_research::sat::IntegerArgumentProto* temp = constraint_.int_mod_;
    constraint_.int_mod_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_int_mod(::operations_research::sat::IntegerArgumentProto* int_mod) {
  clear_constraint();
  if (int_mod) {
    set_has_int_mod();
    constraint_.int_mod_ = int_mod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_mod)
}

// optional .operations_research.sat.IntegerArgumentProto int_max = 9;
inline bool ConstraintProto::has_int_max() const {
  return constraint_case() == kIntMax;
}
inline void ConstraintProto::set_has_int_max() {
  _oneof_case_[0] = kIntMax;
}
inline void ConstraintProto::clear_int_max() {
  if (has_int_max()) {
    delete constraint_.int_max_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntegerArgumentProto& ConstraintProto::int_max() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_max)
  return has_int_max()
      ? *constraint_.int_max_
      : ::operations_research::sat::IntegerArgumentProto::default_instance();
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::mutable_int_max() {
  if (!has_int_max()) {
    clear_constraint();
    set_has_int_max();
    constraint_.int_max_ = new ::operations_research::sat::IntegerArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_max)
  return constraint_.int_max_;
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::release_int_max() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_max)
  if (has_int_max()) {
    clear_has_constraint();
    ::operations_research::sat::IntegerArgumentProto* temp = constraint_.int_max_;
    constraint_.int_max_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_int_max(::operations_research::sat::IntegerArgumentProto* int_max) {
  clear_constraint();
  if (int_max) {
    set_has_int_max();
    constraint_.int_max_ = int_max;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_max)
}

// optional .operations_research.sat.IntegerArgumentProto int_min = 10;
inline bool ConstraintProto::has_int_min() const {
  return constraint_case() == kIntMin;
}
inline void ConstraintProto::set_has_int_min() {
  _oneof_case_[0] = kIntMin;
}
inline void ConstraintProto::clear_int_min() {
  if (has_int_min()) {
    delete constraint_.int_min_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntegerArgumentProto& ConstraintProto::int_min() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_min)
  return has_int_min()
      ? *constraint_.int_min_
      : ::operations_research::sat::IntegerArgumentProto::default_instance();
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::mutable_int_min() {
  if (!has_int_min()) {
    clear_constraint();
    set_has_int_min();
    constraint_.int_min_ = new ::operations_research::sat::IntegerArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_min)
  return constraint_.int_min_;
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::release_int_min() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_min)
  if (has_int_min()) {
    clear_has_constraint();
    ::operations_research::sat::IntegerArgumentProto* temp = constraint_.int_min_;
    constraint_.int_min_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_int_min(::operations_research::sat::IntegerArgumentProto* int_min) {
  clear_constraint();
  if (int_min) {
    set_has_int_min();
    constraint_.int_min_ = int_min;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_min)
}

// optional .operations_research.sat.IntegerArgumentProto int_prod = 11;
inline bool ConstraintProto::has_int_prod() const {
  return constraint_case() == kIntProd;
}
inline void ConstraintProto::set_has_int_prod() {
  _oneof_case_[0] = kIntProd;
}
inline void ConstraintProto::clear_int_prod() {
  if (has_int_prod()) {
    delete constraint_.int_prod_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntegerArgumentProto& ConstraintProto::int_prod() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_prod)
  return has_int_prod()
      ? *constraint_.int_prod_
      : ::operations_research::sat::IntegerArgumentProto::default_instance();
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::mutable_int_prod() {
  if (!has_int_prod()) {
    clear_constraint();
    set_has_int_prod();
    constraint_.int_prod_ = new ::operations_research::sat::IntegerArgumentProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_prod)
  return constraint_.int_prod_;
}
inline ::operations_research::sat::IntegerArgumentProto* ConstraintProto::release_int_prod() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_prod)
  if (has_int_prod()) {
    clear_has_constraint();
    ::operations_research::sat::IntegerArgumentProto* temp = constraint_.int_prod_;
    constraint_.int_prod_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_int_prod(::operations_research::sat::IntegerArgumentProto* int_prod) {
  clear_constraint();
  if (int_prod) {
    set_has_int_prod();
    constraint_.int_prod_ = int_prod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_prod)
}

// optional .operations_research.sat.LinearConstraintProto linear = 12;
inline bool ConstraintProto::has_linear() const {
  return constraint_case() == kLinear;
}
inline void ConstraintProto::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void ConstraintProto::clear_linear() {
  if (has_linear()) {
    delete constraint_.linear_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::LinearConstraintProto& ConstraintProto::linear() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.linear)
  return has_linear()
      ? *constraint_.linear_
      : ::operations_research::sat::LinearConstraintProto::default_instance();
}
inline ::operations_research::sat::LinearConstraintProto* ConstraintProto::mutable_linear() {
  if (!has_linear()) {
    clear_constraint();
    set_has_linear();
    constraint_.linear_ = new ::operations_research::sat::LinearConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.linear)
  return constraint_.linear_;
}
inline ::operations_research::sat::LinearConstraintProto* ConstraintProto::release_linear() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.linear)
  if (has_linear()) {
    clear_has_constraint();
    ::operations_research::sat::LinearConstraintProto* temp = constraint_.linear_;
    constraint_.linear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_linear(::operations_research::sat::LinearConstraintProto* linear) {
  clear_constraint();
  if (linear) {
    set_has_linear();
    constraint_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.linear)
}

// optional .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
inline bool ConstraintProto::has_all_diff() const {
  return constraint_case() == kAllDiff;
}
inline void ConstraintProto::set_has_all_diff() {
  _oneof_case_[0] = kAllDiff;
}
inline void ConstraintProto::clear_all_diff() {
  if (has_all_diff()) {
    delete constraint_.all_diff_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::AllDifferentConstraintProto& ConstraintProto::all_diff() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.all_diff)
  return has_all_diff()
      ? *constraint_.all_diff_
      : ::operations_research::sat::AllDifferentConstraintProto::default_instance();
}
inline ::operations_research::sat::AllDifferentConstraintProto* ConstraintProto::mutable_all_diff() {
  if (!has_all_diff()) {
    clear_constraint();
    set_has_all_diff();
    constraint_.all_diff_ = new ::operations_research::sat::AllDifferentConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.all_diff)
  return constraint_.all_diff_;
}
inline ::operations_research::sat::AllDifferentConstraintProto* ConstraintProto::release_all_diff() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.all_diff)
  if (has_all_diff()) {
    clear_has_constraint();
    ::operations_research::sat::AllDifferentConstraintProto* temp = constraint_.all_diff_;
    constraint_.all_diff_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* all_diff) {
  clear_constraint();
  if (all_diff) {
    set_has_all_diff();
    constraint_.all_diff_ = all_diff;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.all_diff)
}

// optional .operations_research.sat.ElementConstraintProto element = 14;
inline bool ConstraintProto::has_element() const {
  return constraint_case() == kElement;
}
inline void ConstraintProto::set_has_element() {
  _oneof_case_[0] = kElement;
}
inline void ConstraintProto::clear_element() {
  if (has_element()) {
    delete constraint_.element_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::ElementConstraintProto& ConstraintProto::element() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.element)
  return has_element()
      ? *constraint_.element_
      : ::operations_research::sat::ElementConstraintProto::default_instance();
}
inline ::operations_research::sat::ElementConstraintProto* ConstraintProto::mutable_element() {
  if (!has_element()) {
    clear_constraint();
    set_has_element();
    constraint_.element_ = new ::operations_research::sat::ElementConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.element)
  return constraint_.element_;
}
inline ::operations_research::sat::ElementConstraintProto* ConstraintProto::release_element() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.element)
  if (has_element()) {
    clear_has_constraint();
    ::operations_research::sat::ElementConstraintProto* temp = constraint_.element_;
    constraint_.element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_element(::operations_research::sat::ElementConstraintProto* element) {
  clear_constraint();
  if (element) {
    set_has_element();
    constraint_.element_ = element;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.element)
}

// optional .operations_research.sat.CircuitConstraintProto circuit = 15;
inline bool ConstraintProto::has_circuit() const {
  return constraint_case() == kCircuit;
}
inline void ConstraintProto::set_has_circuit() {
  _oneof_case_[0] = kCircuit;
}
inline void ConstraintProto::clear_circuit() {
  if (has_circuit()) {
    delete constraint_.circuit_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::CircuitConstraintProto& ConstraintProto::circuit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.circuit)
  return has_circuit()
      ? *constraint_.circuit_
      : ::operations_research::sat::CircuitConstraintProto::default_instance();
}
inline ::operations_research::sat::CircuitConstraintProto* ConstraintProto::mutable_circuit() {
  if (!has_circuit()) {
    clear_constraint();
    set_has_circuit();
    constraint_.circuit_ = new ::operations_research::sat::CircuitConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.circuit)
  return constraint_.circuit_;
}
inline ::operations_research::sat::CircuitConstraintProto* ConstraintProto::release_circuit() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.circuit)
  if (has_circuit()) {
    clear_has_constraint();
    ::operations_research::sat::CircuitConstraintProto* temp = constraint_.circuit_;
    constraint_.circuit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* circuit) {
  clear_constraint();
  if (circuit) {
    set_has_circuit();
    constraint_.circuit_ = circuit;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.circuit)
}

// optional .operations_research.sat.TableConstraintProto table = 16;
inline bool ConstraintProto::has_table() const {
  return constraint_case() == kTable;
}
inline void ConstraintProto::set_has_table() {
  _oneof_case_[0] = kTable;
}
inline void ConstraintProto::clear_table() {
  if (has_table()) {
    delete constraint_.table_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::TableConstraintProto& ConstraintProto::table() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.table)
  return has_table()
      ? *constraint_.table_
      : ::operations_research::sat::TableConstraintProto::default_instance();
}
inline ::operations_research::sat::TableConstraintProto* ConstraintProto::mutable_table() {
  if (!has_table()) {
    clear_constraint();
    set_has_table();
    constraint_.table_ = new ::operations_research::sat::TableConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.table)
  return constraint_.table_;
}
inline ::operations_research::sat::TableConstraintProto* ConstraintProto::release_table() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.table)
  if (has_table()) {
    clear_has_constraint();
    ::operations_research::sat::TableConstraintProto* temp = constraint_.table_;
    constraint_.table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_table(::operations_research::sat::TableConstraintProto* table) {
  clear_constraint();
  if (table) {
    set_has_table();
    constraint_.table_ = table;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.table)
}

// optional .operations_research.sat.AutomataConstraintProto automata = 17;
inline bool ConstraintProto::has_automata() const {
  return constraint_case() == kAutomata;
}
inline void ConstraintProto::set_has_automata() {
  _oneof_case_[0] = kAutomata;
}
inline void ConstraintProto::clear_automata() {
  if (has_automata()) {
    delete constraint_.automata_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::AutomataConstraintProto& ConstraintProto::automata() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.automata)
  return has_automata()
      ? *constraint_.automata_
      : ::operations_research::sat::AutomataConstraintProto::default_instance();
}
inline ::operations_research::sat::AutomataConstraintProto* ConstraintProto::mutable_automata() {
  if (!has_automata()) {
    clear_constraint();
    set_has_automata();
    constraint_.automata_ = new ::operations_research::sat::AutomataConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.automata)
  return constraint_.automata_;
}
inline ::operations_research::sat::AutomataConstraintProto* ConstraintProto::release_automata() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.automata)
  if (has_automata()) {
    clear_has_constraint();
    ::operations_research::sat::AutomataConstraintProto* temp = constraint_.automata_;
    constraint_.automata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_automata(::operations_research::sat::AutomataConstraintProto* automata) {
  clear_constraint();
  if (automata) {
    set_has_automata();
    constraint_.automata_ = automata;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.automata)
}

// optional .operations_research.sat.InverseConstraintProto inverse = 18;
inline bool ConstraintProto::has_inverse() const {
  return constraint_case() == kInverse;
}
inline void ConstraintProto::set_has_inverse() {
  _oneof_case_[0] = kInverse;
}
inline void ConstraintProto::clear_inverse() {
  if (has_inverse()) {
    delete constraint_.inverse_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::InverseConstraintProto& ConstraintProto::inverse() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.inverse)
  return has_inverse()
      ? *constraint_.inverse_
      : ::operations_research::sat::InverseConstraintProto::default_instance();
}
inline ::operations_research::sat::InverseConstraintProto* ConstraintProto::mutable_inverse() {
  if (!has_inverse()) {
    clear_constraint();
    set_has_inverse();
    constraint_.inverse_ = new ::operations_research::sat::InverseConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.inverse)
  return constraint_.inverse_;
}
inline ::operations_research::sat::InverseConstraintProto* ConstraintProto::release_inverse() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.inverse)
  if (has_inverse()) {
    clear_has_constraint();
    ::operations_research::sat::InverseConstraintProto* temp = constraint_.inverse_;
    constraint_.inverse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_inverse(::operations_research::sat::InverseConstraintProto* inverse) {
  clear_constraint();
  if (inverse) {
    set_has_inverse();
    constraint_.inverse_ = inverse;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.inverse)
}

// optional .operations_research.sat.IntervalConstraintProto interval = 19;
inline bool ConstraintProto::has_interval() const {
  return constraint_case() == kInterval;
}
inline void ConstraintProto::set_has_interval() {
  _oneof_case_[0] = kInterval;
}
inline void ConstraintProto::clear_interval() {
  if (has_interval()) {
    delete constraint_.interval_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::IntervalConstraintProto& ConstraintProto::interval() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.interval)
  return has_interval()
      ? *constraint_.interval_
      : ::operations_research::sat::IntervalConstraintProto::default_instance();
}
inline ::operations_research::sat::IntervalConstraintProto* ConstraintProto::mutable_interval() {
  if (!has_interval()) {
    clear_constraint();
    set_has_interval();
    constraint_.interval_ = new ::operations_research::sat::IntervalConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.interval)
  return constraint_.interval_;
}
inline ::operations_research::sat::IntervalConstraintProto* ConstraintProto::release_interval() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.interval)
  if (has_interval()) {
    clear_has_constraint();
    ::operations_research::sat::IntervalConstraintProto* temp = constraint_.interval_;
    constraint_.interval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_interval(::operations_research::sat::IntervalConstraintProto* interval) {
  clear_constraint();
  if (interval) {
    set_has_interval();
    constraint_.interval_ = interval;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.interval)
}

// optional .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
inline bool ConstraintProto::has_no_overlap() const {
  return constraint_case() == kNoOverlap;
}
inline void ConstraintProto::set_has_no_overlap() {
  _oneof_case_[0] = kNoOverlap;
}
inline void ConstraintProto::clear_no_overlap() {
  if (has_no_overlap()) {
    delete constraint_.no_overlap_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::NoOverlapConstraintProto& ConstraintProto::no_overlap() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.no_overlap)
  return has_no_overlap()
      ? *constraint_.no_overlap_
      : ::operations_research::sat::NoOverlapConstraintProto::default_instance();
}
inline ::operations_research::sat::NoOverlapConstraintProto* ConstraintProto::mutable_no_overlap() {
  if (!has_no_overlap()) {
    clear_constraint();
    set_has_no_overlap();
    constraint_.no_overlap_ = new ::operations_research::sat::NoOverlapConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.no_overlap)
  return constraint_.no_overlap_;
}
inline ::operations_research::sat::NoOverlapConstraintProto* ConstraintProto::release_no_overlap() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.no_overlap)
  if (has_no_overlap()) {
    clear_has_constraint();
    ::operations_research::sat::NoOverlapConstraintProto* temp = constraint_.no_overlap_;
    constraint_.no_overlap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* no_overlap) {
  clear_constraint();
  if (no_overlap) {
    set_has_no_overlap();
    constraint_.no_overlap_ = no_overlap;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap)
}

// optional .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
inline bool ConstraintProto::has_no_overlap_2d() const {
  return constraint_case() == kNoOverlap2D;
}
inline void ConstraintProto::set_has_no_overlap_2d() {
  _oneof_case_[0] = kNoOverlap2D;
}
inline void ConstraintProto::clear_no_overlap_2d() {
  if (has_no_overlap_2d()) {
    delete constraint_.no_overlap_2d_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::NoOverlap2DConstraintProto& ConstraintProto::no_overlap_2d() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.no_overlap_2d)
  return has_no_overlap_2d()
      ? *constraint_.no_overlap_2d_
      : ::operations_research::sat::NoOverlap2DConstraintProto::default_instance();
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* ConstraintProto::mutable_no_overlap_2d() {
  if (!has_no_overlap_2d()) {
    clear_constraint();
    set_has_no_overlap_2d();
    constraint_.no_overlap_2d_ = new ::operations_research::sat::NoOverlap2DConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.no_overlap_2d)
  return constraint_.no_overlap_2d_;
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* ConstraintProto::release_no_overlap_2d() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.no_overlap_2d)
  if (has_no_overlap_2d()) {
    clear_has_constraint();
    ::operations_research::sat::NoOverlap2DConstraintProto* temp = constraint_.no_overlap_2d_;
    constraint_.no_overlap_2d_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* no_overlap_2d) {
  clear_constraint();
  if (no_overlap_2d) {
    set_has_no_overlap_2d();
    constraint_.no_overlap_2d_ = no_overlap_2d;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap_2d)
}

// optional .operations_research.sat.CumulativeConstraintProto cumulative = 22;
inline bool ConstraintProto::has_cumulative() const {
  return constraint_case() == kCumulative;
}
inline void ConstraintProto::set_has_cumulative() {
  _oneof_case_[0] = kCumulative;
}
inline void ConstraintProto::clear_cumulative() {
  if (has_cumulative()) {
    delete constraint_.cumulative_;
    clear_has_constraint();
  }
}
inline  const ::operations_research::sat::CumulativeConstraintProto& ConstraintProto::cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.cumulative)
  return has_cumulative()
      ? *constraint_.cumulative_
      : ::operations_research::sat::CumulativeConstraintProto::default_instance();
}
inline ::operations_research::sat::CumulativeConstraintProto* ConstraintProto::mutable_cumulative() {
  if (!has_cumulative()) {
    clear_constraint();
    set_has_cumulative();
    constraint_.cumulative_ = new ::operations_research::sat::CumulativeConstraintProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.cumulative)
  return constraint_.cumulative_;
}
inline ::operations_research::sat::CumulativeConstraintProto* ConstraintProto::release_cumulative() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.cumulative)
  if (has_cumulative()) {
    clear_has_constraint();
    ::operations_research::sat::CumulativeConstraintProto* temp = constraint_.cumulative_;
    constraint_.cumulative_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConstraintProto::set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* cumulative) {
  clear_constraint();
  if (cumulative) {
    set_has_cumulative();
    constraint_.cumulative_ = cumulative;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.cumulative)
}

inline bool ConstraintProto::has_constraint() const {
  return constraint_case() != CONSTRAINT_NOT_SET;
}
inline void ConstraintProto::clear_has_constraint() {
  _oneof_case_[0] = CONSTRAINT_NOT_SET;
}
inline ConstraintProto::ConstraintCase ConstraintProto::constraint_case() const {
  return ConstraintProto::ConstraintCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CpObjectiveProto

// repeated int32 vars = 1;
inline int CpObjectiveProto::vars_size() const {
  return vars_.size();
}
inline void CpObjectiveProto::clear_vars() {
  vars_.Clear();
}
inline ::google::protobuf::int32 CpObjectiveProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.vars)
  return vars_.Get(index);
}
inline void CpObjectiveProto::set_vars(int index, ::google::protobuf::int32 value) {
  vars_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.vars)
}
inline void CpObjectiveProto::add_vars(::google::protobuf::int32 value) {
  vars_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpObjectiveProto.vars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CpObjectiveProto::vars() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpObjectiveProto.vars)
  return vars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CpObjectiveProto::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpObjectiveProto.vars)
  return &vars_;
}

// repeated int64 coeffs = 4;
inline int CpObjectiveProto::coeffs_size() const {
  return coeffs_.size();
}
inline void CpObjectiveProto::clear_coeffs() {
  coeffs_.Clear();
}
inline ::google::protobuf::int64 CpObjectiveProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.coeffs)
  return coeffs_.Get(index);
}
inline void CpObjectiveProto::set_coeffs(int index, ::google::protobuf::int64 value) {
  coeffs_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.coeffs)
}
inline void CpObjectiveProto::add_coeffs(::google::protobuf::int64 value) {
  coeffs_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpObjectiveProto.coeffs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CpObjectiveProto::coeffs() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpObjectiveProto.coeffs)
  return coeffs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CpObjectiveProto::mutable_coeffs() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpObjectiveProto.coeffs)
  return &coeffs_;
}

// optional double offset = 2;
inline void CpObjectiveProto::clear_offset() {
  offset_ = 0;
}
inline double CpObjectiveProto::offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.offset)
  return offset_;
}
inline void CpObjectiveProto::set_offset(double value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.offset)
}

// optional double scaling_factor = 3;
inline void CpObjectiveProto::clear_scaling_factor() {
  scaling_factor_ = 0;
}
inline double CpObjectiveProto::scaling_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.scaling_factor)
  return scaling_factor_;
}
inline void CpObjectiveProto::set_scaling_factor(double value) {
  
  scaling_factor_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.scaling_factor)
}

// -------------------------------------------------------------------

// DecisionStrategyProto_AffineTransformation

// optional int32 var = 1;
inline void DecisionStrategyProto_AffineTransformation::clear_var() {
  var_ = 0;
}
inline ::google::protobuf::int32 DecisionStrategyProto_AffineTransformation::var() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.AffineTransformation.var)
  return var_;
}
inline void DecisionStrategyProto_AffineTransformation::set_var(::google::protobuf::int32 value) {
  
  var_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.AffineTransformation.var)
}

// optional int64 offset = 2;
inline void DecisionStrategyProto_AffineTransformation::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DecisionStrategyProto_AffineTransformation::offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.AffineTransformation.offset)
  return offset_;
}
inline void DecisionStrategyProto_AffineTransformation::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.AffineTransformation.offset)
}

// optional int64 positive_coeff = 3;
inline void DecisionStrategyProto_AffineTransformation::clear_positive_coeff() {
  positive_coeff_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DecisionStrategyProto_AffineTransformation::positive_coeff() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.AffineTransformation.positive_coeff)
  return positive_coeff_;
}
inline void DecisionStrategyProto_AffineTransformation::set_positive_coeff(::google::protobuf::int64 value) {
  
  positive_coeff_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.AffineTransformation.positive_coeff)
}

// -------------------------------------------------------------------

// DecisionStrategyProto

// repeated int32 variables = 1;
inline int DecisionStrategyProto::variables_size() const {
  return variables_.size();
}
inline void DecisionStrategyProto::clear_variables() {
  variables_.Clear();
}
inline ::google::protobuf::int32 DecisionStrategyProto::variables(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.variables)
  return variables_.Get(index);
}
inline void DecisionStrategyProto::set_variables(int index, ::google::protobuf::int32 value) {
  variables_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.variables)
}
inline void DecisionStrategyProto::add_variables(::google::protobuf::int32 value) {
  variables_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.DecisionStrategyProto.variables)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DecisionStrategyProto::variables() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.DecisionStrategyProto.variables)
  return variables_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DecisionStrategyProto::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.DecisionStrategyProto.variables)
  return &variables_;
}

// optional .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
inline void DecisionStrategyProto::clear_variable_selection_strategy() {
  variable_selection_strategy_ = 0;
}
inline ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::variable_selection_strategy() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.variable_selection_strategy)
  return static_cast< ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy >(variable_selection_strategy_);
}
inline void DecisionStrategyProto::set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value) {
  
  variable_selection_strategy_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.variable_selection_strategy)
}

// optional .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
inline void DecisionStrategyProto::clear_domain_reduction_strategy() {
  domain_reduction_strategy_ = 0;
}
inline ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::domain_reduction_strategy() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.domain_reduction_strategy)
  return static_cast< ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy >(domain_reduction_strategy_);
}
inline void DecisionStrategyProto::set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value) {
  
  domain_reduction_strategy_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.domain_reduction_strategy)
}

// repeated .operations_research.sat.DecisionStrategyProto.AffineTransformation transformations = 4;
inline int DecisionStrategyProto::transformations_size() const {
  return transformations_.size();
}
inline void DecisionStrategyProto::clear_transformations() {
  transformations_.Clear();
}
inline const ::operations_research::sat::DecisionStrategyProto_AffineTransformation& DecisionStrategyProto::transformations(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.transformations)
  return transformations_.Get(index);
}
inline ::operations_research::sat::DecisionStrategyProto_AffineTransformation* DecisionStrategyProto::mutable_transformations(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.DecisionStrategyProto.transformations)
  return transformations_.Mutable(index);
}
inline ::operations_research::sat::DecisionStrategyProto_AffineTransformation* DecisionStrategyProto::add_transformations() {
  // @@protoc_insertion_point(field_add:operations_research.sat.DecisionStrategyProto.transformations)
  return transformations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >*
DecisionStrategyProto::mutable_transformations() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.DecisionStrategyProto.transformations)
  return &transformations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >&
DecisionStrategyProto::transformations() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.DecisionStrategyProto.transformations)
  return transformations_;
}

// -------------------------------------------------------------------

// CpModelProto

// optional string name = 1;
inline void CpModelProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CpModelProto::name() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CpModelProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpModelProto.name)
}
inline void CpModelProto::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:operations_research.sat.CpModelProto.name)
}
inline void CpModelProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.CpModelProto.name)
}
inline ::std::string* CpModelProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CpModelProto::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CpModelProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.name)
}

// repeated .operations_research.sat.IntegerVariableProto variables = 2;
inline int CpModelProto::variables_size() const {
  return variables_.size();
}
inline void CpModelProto::clear_variables() {
  variables_.Clear();
}
inline const ::operations_research::sat::IntegerVariableProto& CpModelProto::variables(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.variables)
  return variables_.Get(index);
}
inline ::operations_research::sat::IntegerVariableProto* CpModelProto::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.variables)
  return variables_.Mutable(index);
}
inline ::operations_research::sat::IntegerVariableProto* CpModelProto::add_variables() {
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.variables)
  return variables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto >*
CpModelProto::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.variables)
  return &variables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto >&
CpModelProto::variables() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.variables)
  return variables_;
}

// repeated .operations_research.sat.ConstraintProto constraints = 3;
inline int CpModelProto::constraints_size() const {
  return constraints_.size();
}
inline void CpModelProto::clear_constraints() {
  constraints_.Clear();
}
inline const ::operations_research::sat::ConstraintProto& CpModelProto::constraints(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.constraints)
  return constraints_.Get(index);
}
inline ::operations_research::sat::ConstraintProto* CpModelProto::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.constraints)
  return constraints_.Mutable(index);
}
inline ::operations_research::sat::ConstraintProto* CpModelProto::add_constraints() {
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.constraints)
  return constraints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto >*
CpModelProto::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.constraints)
  return &constraints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto >&
CpModelProto::constraints() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.constraints)
  return constraints_;
}

// optional .operations_research.sat.CpObjectiveProto objective = 4;
inline bool CpModelProto::has_objective() const {
  return !_is_default_instance_ && objective_ != NULL;
}
inline void CpModelProto::clear_objective() {
  if (GetArenaNoVirtual() == NULL && objective_ != NULL) delete objective_;
  objective_ = NULL;
}
inline const ::operations_research::sat::CpObjectiveProto& CpModelProto::objective() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.objective)
  return objective_ != NULL ? *objective_ : *default_instance_->objective_;
}
inline ::operations_research::sat::CpObjectiveProto* CpModelProto::mutable_objective() {
  
  if (objective_ == NULL) {
    objective_ = new ::operations_research::sat::CpObjectiveProto;
  }
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.objective)
  return objective_;
}
inline ::operations_research::sat::CpObjectiveProto* CpModelProto::release_objective() {
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.objective)
  
  ::operations_research::sat::CpObjectiveProto* temp = objective_;
  objective_ = NULL;
  return temp;
}
inline void CpModelProto::set_allocated_objective(::operations_research::sat::CpObjectiveProto* objective) {
  delete objective_;
  objective_ = objective;
  if (objective) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.objective)
}

// repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
inline int CpModelProto::search_strategy_size() const {
  return search_strategy_.size();
}
inline void CpModelProto::clear_search_strategy() {
  search_strategy_.Clear();
}
inline const ::operations_research::sat::DecisionStrategyProto& CpModelProto::search_strategy(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.search_strategy)
  return search_strategy_.Get(index);
}
inline ::operations_research::sat::DecisionStrategyProto* CpModelProto::mutable_search_strategy(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.search_strategy)
  return search_strategy_.Mutable(index);
}
inline ::operations_research::sat::DecisionStrategyProto* CpModelProto::add_search_strategy() {
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.search_strategy)
  return search_strategy_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto >*
CpModelProto::mutable_search_strategy() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.search_strategy)
  return &search_strategy_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto >&
CpModelProto::search_strategy() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.search_strategy)
  return search_strategy_;
}

// -------------------------------------------------------------------

// CpSolverResponse

// optional .operations_research.sat.CpSolverStatus status = 1;
inline void CpSolverResponse::clear_status() {
  status_ = 0;
}
inline ::operations_research::sat::CpSolverStatus CpSolverResponse::status() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.status)
  return static_cast< ::operations_research::sat::CpSolverStatus >(status_);
}
inline void CpSolverResponse::set_status(::operations_research::sat::CpSolverStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.status)
}

// repeated int64 solution = 2;
inline int CpSolverResponse::solution_size() const {
  return solution_.size();
}
inline void CpSolverResponse::clear_solution() {
  solution_.Clear();
}
inline ::google::protobuf::int64 CpSolverResponse::solution(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solution)
  return solution_.Get(index);
}
inline void CpSolverResponse::set_solution(int index, ::google::protobuf::int64 value) {
  solution_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solution)
}
inline void CpSolverResponse::add_solution(::google::protobuf::int64 value) {
  solution_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.solution)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CpSolverResponse::solution() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.solution)
  return solution_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CpSolverResponse::mutable_solution() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.solution)
  return &solution_;
}

// repeated int64 solution_lower_bounds = 18;
inline int CpSolverResponse::solution_lower_bounds_size() const {
  return solution_lower_bounds_.size();
}
inline void CpSolverResponse::clear_solution_lower_bounds() {
  solution_lower_bounds_.Clear();
}
inline ::google::protobuf::int64 CpSolverResponse::solution_lower_bounds(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solution_lower_bounds)
  return solution_lower_bounds_.Get(index);
}
inline void CpSolverResponse::set_solution_lower_bounds(int index, ::google::protobuf::int64 value) {
  solution_lower_bounds_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solution_lower_bounds)
}
inline void CpSolverResponse::add_solution_lower_bounds(::google::protobuf::int64 value) {
  solution_lower_bounds_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.solution_lower_bounds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CpSolverResponse::solution_lower_bounds() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.solution_lower_bounds)
  return solution_lower_bounds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CpSolverResponse::mutable_solution_lower_bounds() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.solution_lower_bounds)
  return &solution_lower_bounds_;
}

// repeated int64 solution_upper_bounds = 19;
inline int CpSolverResponse::solution_upper_bounds_size() const {
  return solution_upper_bounds_.size();
}
inline void CpSolverResponse::clear_solution_upper_bounds() {
  solution_upper_bounds_.Clear();
}
inline ::google::protobuf::int64 CpSolverResponse::solution_upper_bounds(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solution_upper_bounds)
  return solution_upper_bounds_.Get(index);
}
inline void CpSolverResponse::set_solution_upper_bounds(int index, ::google::protobuf::int64 value) {
  solution_upper_bounds_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solution_upper_bounds)
}
inline void CpSolverResponse::add_solution_upper_bounds(::google::protobuf::int64 value) {
  solution_upper_bounds_.Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.solution_upper_bounds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CpSolverResponse::solution_upper_bounds() const {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.solution_upper_bounds)
  return solution_upper_bounds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CpSolverResponse::mutable_solution_upper_bounds() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.solution_upper_bounds)
  return &solution_upper_bounds_;
}

// optional double objective_value = 3;
inline void CpSolverResponse::clear_objective_value() {
  objective_value_ = 0;
}
inline double CpSolverResponse::objective_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.objective_value)
  return objective_value_;
}
inline void CpSolverResponse::set_objective_value(double value) {
  
  objective_value_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.objective_value)
}

// optional double best_objective_bound = 4;
inline void CpSolverResponse::clear_best_objective_bound() {
  best_objective_bound_ = 0;
}
inline double CpSolverResponse::best_objective_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.best_objective_bound)
  return best_objective_bound_;
}
inline void CpSolverResponse::set_best_objective_bound(double value) {
  
  best_objective_bound_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.best_objective_bound)
}

// optional bool all_solutions_were_found = 5;
inline void CpSolverResponse::clear_all_solutions_were_found() {
  all_solutions_were_found_ = false;
}
inline bool CpSolverResponse::all_solutions_were_found() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.all_solutions_were_found)
  return all_solutions_were_found_;
}
inline void CpSolverResponse::set_all_solutions_were_found(bool value) {
  
  all_solutions_were_found_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.all_solutions_were_found)
}

// optional int64 num_booleans = 10;
inline void CpSolverResponse::clear_num_booleans() {
  num_booleans_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpSolverResponse::num_booleans() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_booleans)
  return num_booleans_;
}
inline void CpSolverResponse::set_num_booleans(::google::protobuf::int64 value) {
  
  num_booleans_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_booleans)
}

// optional int64 num_conflicts = 11;
inline void CpSolverResponse::clear_num_conflicts() {
  num_conflicts_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpSolverResponse::num_conflicts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_conflicts)
  return num_conflicts_;
}
inline void CpSolverResponse::set_num_conflicts(::google::protobuf::int64 value) {
  
  num_conflicts_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_conflicts)
}

// optional int64 num_branches = 12;
inline void CpSolverResponse::clear_num_branches() {
  num_branches_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpSolverResponse::num_branches() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_branches)
  return num_branches_;
}
inline void CpSolverResponse::set_num_branches(::google::protobuf::int64 value) {
  
  num_branches_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_branches)
}

// optional int64 num_binary_propagations = 13;
inline void CpSolverResponse::clear_num_binary_propagations() {
  num_binary_propagations_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpSolverResponse::num_binary_propagations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_binary_propagations)
  return num_binary_propagations_;
}
inline void CpSolverResponse::set_num_binary_propagations(::google::protobuf::int64 value) {
  
  num_binary_propagations_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_binary_propagations)
}

// optional int64 num_integer_propagations = 14;
inline void CpSolverResponse::clear_num_integer_propagations() {
  num_integer_propagations_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpSolverResponse::num_integer_propagations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_integer_propagations)
  return num_integer_propagations_;
}
inline void CpSolverResponse::set_num_integer_propagations(::google::protobuf::int64 value) {
  
  num_integer_propagations_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_integer_propagations)
}

// optional double wall_time = 15;
inline void CpSolverResponse::clear_wall_time() {
  wall_time_ = 0;
}
inline double CpSolverResponse::wall_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.wall_time)
  return wall_time_;
}
inline void CpSolverResponse::set_wall_time(double value) {
  
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.wall_time)
}

// optional double user_time = 16;
inline void CpSolverResponse::clear_user_time() {
  user_time_ = 0;
}
inline double CpSolverResponse::user_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.user_time)
  return user_time_;
}
inline void CpSolverResponse::set_user_time(double value) {
  
  user_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.user_time)
}

// optional double deterministic_time = 17;
inline void CpSolverResponse::clear_deterministic_time() {
  deterministic_time_ = 0;
}
inline double CpSolverResponse::deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.deterministic_time)
  return deterministic_time_;
}
inline void CpSolverResponse::set_deterministic_time(double value) {
  
  deterministic_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.deterministic_time)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sat
}  // namespace operations_research

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy>() {
  return ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy_descriptor();
}
template <> struct is_proto_enum< ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy>() {
  return ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy_descriptor();
}
template <> struct is_proto_enum< ::operations_research::sat::CpSolverStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::sat::CpSolverStatus>() {
  return ::operations_research::sat::CpSolverStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ortools_2fsat_2fcp_5fmodel_2eproto__INCLUDED
